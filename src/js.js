function $id(id) {
	return document.getElementById(id);
}
(function() {
	"use strict"
	var sameHeader = function(cellHeader, colHeader, rowN) {
			if (rowN !== 0) {
				colHeader = (/[a-z].*/i.exec(colHeader) || ["l"])[0];
			}
			return cellHeader == colHeader
		},
		sendGAEvent = function(category, action, label){
			var hash = (location.hash||"").toLowerCase();
			if(window.isProduction && window.ga && hash != "#anonymous" && hash != "#/anonymous"){
				ga('send', 'event', category, action, label);
			}
		},
		// From here : https://codereview.stackexchange.com/questions/16124/
		//             implement-numbering-scheme-like-a-b-c-aa-ab-aaa-similar-to-converting
		toZZZ = function(number) {
			var baseChar = ("A").charCodeAt(0),
			letters  = "";
			do {
				number -= 1;
				letters = String.fromCharCode(baseChar + (number % 26)) + letters;
				number = (number / 26) >> 0;
			} while(number > 0);
			return letters;
		},
		packagesDatabase = {
			"array" : [],
			"arydshln" : [],
			"booktabs" : [],
			"color" : [],
			"colortbl" : ["array", "color"],
			"diagbox" : ["keyval","pict2e","fp"],
			"fp" : ["defpattern","fp-basic","fp-addons","fp-snap","fp-exp",
			       "fp-trigo","fp-pas","fp-random","fp-eqn","fp-upn","fp-eval"],
			"graphics" : ["trig"],
			"graphicx" : ["keyval", "graphics"],
			"hhline" : [],
			"makecell" : ["array"],
			"multirow" : [],
			"ragged2e" : ["everysel"],
			"rotating" : ["graphicx", "ifthen"],
			"slashbox" : [],
			"tabu" : ["array","varwidth"],
			"tabularx" : ["array"],
			"ulem" : []
		},
		rgb2cymk = function(r,g,b){
			var c = 1 - r/255,
			y = 1 - g/255,
			m = 1 - b/255,
			k = Math.min(c,y,m,k);
			c = Math.min(1, Math.max(0, c-k));
			y = Math.min(1, Math.max(0, y-k));
			m = Math.min(1, Math.max(0, m-k));
			return [c,y,m,k]
		},
		noColor = false,
		defaultColors = {
			"1,0,0" : "red",
			"0,1,0" : "green",
			"0,0,1" : "blue",
			"0,1,1" : "cyan",
			"1,0,1" : "magenta",
			"1,1,0" : "yellow",
			"0,0,0" : "black",
			"1,1,1" : "white"
		},
		areSameColors = function(color1, color2){
			if(noColor){return true;}
			if(typeof color1 == "string"){
				color1 = toRGBA(color1);
			}
			if(typeof color2 == "string"){
				color2 = toRGBA(color2);
			}
			for(var i=0;i<3;i++){
				if(color1[i] !== color2[i]){
					return false;
				}
			}
			return true;
		},
		getColor = function(color){
			var arr = []
			if(typeof color == "string"){
				color = toRGBA(color);
			}
			for(var i=0;i<3;i++){
				arr.push(Math.round((+color[i]||0)/255*1000)/1000);
			}
			var sep = arr.join(",");
			if(defaultColors[sep]){
				return "{"+defaultColors[sep]+"}";
			}
			return "[rgb]{"+sep+"}";
		},
		table = new(function() {
			this.version = "0.8.1";
			this.create = function(cols, rows) {
				rows = parseInt(rows, 10);
				cols = parseInt(cols, 10);
				var fr = document.createDocumentFragment();
				for (var i = 0; i < rows; i++) {
					fr.appendChild(this.createRow(cols));
				}
				this.element.innerHTML = "";
				this.element.appendChild(fr);
			};
			this.importData = function(content, format){
				content = content || $id("import_value").value;
				format = (format || $id("import_format").value).toLowerCase();
				if(format == "auto"){
					var json;
					if(/(\\begin{|\\halign|\\valign)/.test(content)){
						try{
							this.importFromJSON(this.latex.importTable(content));
						}
						catch(e){
							try{
								this.importFromJSON(JSON.parse(content));
								$('#importModal').modal('hide');
								sendGAEvent("Code", "import", "latex");
							}
							catch(f){
								alert("Your file was detected as LaTeX but could not be loaded.");
								if(window.console){
									console.error(e);
								}
							}
						}
					}
					else{
						try{
							json = JSON.parse(content);
							sendGAEvent("Code", "import", "json");
						}
						catch(e){
							try{
								json = this.importCSV(content);
								$('#importModal').modal('hide');
								sendGAEvent("Code", "import", "csv");
							}
							catch(f){
								alert("Your file could not be loaded");
								if(window.console){
									console.error(e);
									console.error(f);
								}
								return false;							
							}
						}
						this.importFromJSON(json);
					}
				}
				else if(format == "json"){
					try{
						this.importFromJSON(JSON.parse(content));
						$('#importModal').modal('hide');
						sendGAEvent("Code", "import", "json");
					}
					catch(e){
						alert("Your JSON file could not be loaded. Be sure the JSON was generated by this generator");
					}
				}
				else if(format == "latex"){
					try{
						this.importFromJSON(table.latex.importTable(content));
						$('#importModal').modal('hide');
						sendGAEvent("Code", "import", "latex");
					}
					catch(e){
						if(window.console){
							console.error(e);
						}
						$("#latex-import-error").show();
					}
				}
				else if(format == "csv"){
					try{
						this.importFromJSON(this.importCSV(content));
						$('#importModal').modal('hide');
						sendGAEvent("Code", "import", "csv");
					}
					catch(e){
						alert("Your CSV file could not be loaded");
					}
				}
			}
			this.selectFormat = function(format){
				$("div[data-option-group]").hide();
				$("div[data-option-group=\""+format+"\"]").show();
				$id("format").value = format;
				$id("format-in").value = format;
			}
			this.removeAllSelection = function() {
				this.selectedCell = null;
				var allSelected = document.querySelectorAll("#table td[data-selected]");
				for (var i = 0, l = allSelected.length; i < l; i++) {
					allSelected[i].removeAttribute("data-selected");
				}
			}
			this.forEachSelectedCell = function(fn) {
				var allCells = document.querySelectorAll("#table td[data-selected]");
				for (var i = 0, l = allCells.length; i < l; i++) {
					if (fn.call(this, allCells[i], i) === false) {
						break;
					}
				}
			}
			this.separators = function(hm) {
				$id("info_diag_zero")
					.classList.remove("active");
				$id("info_diag_one")
					.classList.remove("active");
				$id("info_diag_two")
					.classList.remove("active");
				if (hm == 2) {
					$id("info_diag_two")
						.classList.add("active");
					this.twoDiagonals();
				} else if (hm == 1) {
					$id("info_diag_one")
						.classList.add("active");
					this.diagonal();
				} else {
					$id("info_diag_zero")
						.classList.add("active");
					this.forEachSelectedCell(function(cell) {
						if (cell.hasAttribute("data-two-diagonals")) {
							var toDel = cell.querySelector("div[contenteditable]");
							cell.setAttribute("data-two-diagonals-data", toDel.innerHTML);
							toDel.parentElement.removeChild(toDel);
						}
						if (cell.hasAttribute("data-two-diagonals") || cell.hasAttribute("data-diagonal")) {
							var toDel = cell.querySelector("div[contenteditable]:last-child");
							cell.setAttribute("data-diagonal-data", toDel.innerHTML);
							toDel.parentElement.removeChild(toDel);
						}
						cell.removeAttribute("data-two-diagonals");
						cell.removeAttribute("data-diagonal");
					});
				}
			}
			this.interpreters = {};
			this.createInterpreter = function(format, fn) {
				this.interpreters[format] = fn;
			}
			this.interpret = function(format) {
				document.getElementById('c')
					.value = this.interpreters[format].call(this);
			}
			this.insertRowUnder = function(cell) {
				this.statesManager.registerState();
				cell = cell || this.selectedCell;
				if (!cell) {
					return false;
				}
				var position = this.Table.position(cell),
					y = -1;
				if (position) {
					y = position.y + cell.rowSpan;
				}
				var _this = this;
				this.Table.insertRow(y, function(cell) {
					_this.applyToCell(cell)
				});
			}
			this.insertRowOver = function(cell) {
				this.statesManager.registerState();
				cell = cell || this.selectedCell;
				if (!cell) {
					return false;
				}
				var position = this.Table.position(cell),
					y = 0;
				if (position) {
					y = Math.max(position.y, 0);
				}
				var _this = this;
				this.Table.insertRow(y, function(cell) {
					_this.applyToCell(cell)
				});
			}
			this.insertColBefore = function(cell) {
				this.statesManager.registerState();
				cell = cell || this.selectedCell;
				if (!cell) {
					return false;
				}
				var position = this.Table.position(cell),
					x = 0;
				if (position) {
					x = Math.max(position.x, 0);
				}
				var _this = this;
				this.Table.insertCol(x, function(cell) {
					_this.applyToCell(cell)
				});
			}
			this.insertColAfter = function(cell) {
				this.statesManager.registerState();
				cell = cell || this.selectedCell;
				if (!cell) {
					return false;
				}
				var position = this.Table.position(cell),
					x = 0;
				if (position) {
					x = position.x + cell.colSpan;
				}
				var _this = this;
				this.Table.insertCol(x, function(cell) {
					_this.applyToCell(cell)
				});
			}
			this.split = function() {
				this.statesManager.registerState();
				var _this = this;
				this.Table.split(document.querySelectorAll("#table td[data-selected]"), function(cell) {
					_this.applyToCell(cell)
				});
			}
			this.createCellLike = function(cell) {
				var td = this.createCell();
				td.rowSpan = cell.rowSpan;
				td.colSpan = cell.colSpan;
				for (var i in cell.dataset) {
					td.dataset[i] = cell.dataset[i];
				}
				td.removeAttribute("data-selected");
				return td;
			}
			this.textColor = function(color){
				if(color){
					this._id("text-color-input").value = color;
					this._id("text-color-span").style.color = color;
					this._id("text-color-button").setAttribute("data-color", color);
				}
				else{
					return this._id("text-color-button").getAttribute("data-color") || "#000000";
				}
			}
			this.diagonal = function() {
				this.statesManager.registerState();
				this.updateLaTeXInfoCell();
				this.forEachSelectedCell(function(cell) {
					if (!cell.hasAttribute("data-diagonal")) {
						if (cell.hasAttribute("data-two-diagonals")) {
							var toDel = cell.querySelector("div[contenteditable]");
							cell.setAttribute("data-two-diagonals-data", this.getHTML(cell));
							toDel.parentElement.removeChild(toDel);
							cell.removeAttribute("data-two-diagonals");
						} else {
							cell.querySelector(".outer")
								.innerHTML += "<div contenteditable>" + (cell.getAttribute("data-diagonal-data") || "[TEXT UNDER]") +
								"</div>";
						}
						cell.setAttribute("data-diagonal", "data-diagonal")
					}
				});
			}
			this.twoDiagonals = function() {
				this.statesManager.registerState();
				this.updateLaTeXInfoCell();
				this.forEachSelectedCell(function(cell) {
					if (!cell.hasAttribute("data-two-diagonals")) {
						var div = cell.querySelector(".outer");
						if (cell.hasAttribute("data-diagonal")) {
							cell.removeAttribute("data-diagonal");
							div.innerHTML = "<div contenteditable>" + (cell.getAttribute("data-two-diagonals-data") || "[1]") +
								"</div>" + div.innerHTML;
						} else {
							div.innerHTML = "<div contenteditable>" + (cell.getAttribute("data-two-diagonals-data") || "[1]") +
								"</div>" + div.innerHTML + "<div contenteditable>" + (cell.getAttribute("data-diagonal-data") ||
									"[3]") + "</div>";
						}
						cell.setAttribute("data-two-diagonals", "data-two-diagonals");
					}
				});
			}
			this.rotate = function(state) {
				var _this = this;
				this.statesManager.registerState();
				this.forEachSelectedCell(function(cell) {
					if (state) {
						_this.refreshRotatedCellSize(cell);
						cell.setAttribute("data-rotated", "data-rotated");
					} else {
						cell.style.width = cell.style.height = "";
						if(cell.style.removeProperty){
							cell.style.removeProperty("width");
							cell.style.removeProperty("height");
						}
						cell.removeAttribute("data-rotated");
					}
				});
				if(state){
					$id("info-unrotated").classList.remove("active");
					$id("info-rotated").classList.add("active");
				}
				else{
					$id("info-unrotated").classList.add("active");
					$id("info-rotated").classList.remove("active");
				}
				this.updateLaTeXInfoCell();
			}
			this.selectedCell = null;
			this.merge = function() {
				this.statesManager.registerState();
				var _this = this;
				this.Table.merge(document.querySelectorAll("#table td[data-selected]"), function(colspan, rowspan, keep, removed) {
					var html = _this.getHTML(keep);
					for (var i = 0; i < removed.length; i++) {
						html += " " + _this.getHTML(removed[i])
					}
					_this.setHTML(keep, html);
				});
			}
			this.getCellPosition = function(_cell) {
				var table = this.element,
					occupied = [],
					rows = table.rows;
				for (var i = 0; i < rows.length; i++) {
					occupied.push([]);
				}
				for (var i = 0; i < rows.length; i++) {
					var cols = rows[i].cells,
						realcount = 0;
					for (var j = 0; j < cols.length; j++) {
						var cell = cols[j];
						if (occupied[i][realcount]) {
							j--;
							realcount++;
							continue;
						}
						if (cell == _cell) {
							return {
								x: i,
								y: realcount
							}
						}
						for (var h = 1; h < cell.rowSpan; h++) {
							for (var g = 0; g < cell.colSpan; g++) {
								occupied[i + h][realcount + g] = true;
							}
						}
						realcount += cell.colSpan;
					}
				}

			}
			this.getCellByPosition = function(x, y) {
				var table = this.element,
					occupied = [],
					rows = table.rows;
				if (x >= rows.length) {
					return null;
				}
				for (var i = 0; i < rows.length; i++) {
					occupied.push([]);
				}
				for (var i = 0, l = Math.min(rows.length, x + 1); i < l; i++) {
					var cols = rows[i].cells,
						realcount = 0;
					for (var j = 0; j < cols.length; j++) {
						var cell = cols[j];
						if (occupied[i][realcount]) {
							j--;
							realcount++;
							continue;
						}
						if (i == x && realcount == y) {
							return cell;
						}
						for (var h = 1; h < cell.rowSpan; h++) {
							for (var g = 0; g < cell.colSpan; g++) {
								occupied[i + h][realcount + g] = true;
							}
						}
						realcount += cell.colSpan;
					}
				}
			};
			this.unselectCells = function(group) {
				for (var i = 0; i < group.length; i++) {
					group.removeAttribute("data-selected");
				}
			}
			this.setMargin = function(left, value) {
				this.forEachSelectedCell(function(cell) {
					if (left) {
						cell.setAttribute("data-margin-left", value);
					} else {
						cell.setAttribute("data-margin-right", value);
					}
				});
			}
			this.backgroundColor = function(color) {
				this.statesManager.registerState();
				this.forEachSelectedCell(function(cell) {
					cell.style.backgroundColor = color;
				});
			}
			this.removeBackgroundColor = function(color) {
				this.statesManager.registerState();
				this.forEachSelectedCell(function(cell) {
					cell.style.backgroundColor = "";
					if(cell.style.removeProperty){
						cell.style.removeProperty("background-color");
					}
				});
			}
			this.setAlign = function(value) {
				this.statesManager.registerState();
				if (value != "l" && value != "r" && value != "c") {
					value = "l";
				}
				$id("info_align_left")
					.classList.remove("active");
				$id("info_align_center")
					.classList.remove("active");
				$id("info_align_right")
					.classList.remove("active");
				this.forEachSelectedCell(function(cell) {
					cell.setAttribute("data-align", value);
				});
				$id({
						"l": "info_align_left",
						"c": "info_align_center",
						"r": "info_align_right"
					}[value])
					.classList.add("active");
			}

			this.updateLaTeXInfoCell = function(cell) {
				cell = cell || this.selectedCell;
				if (cell) {
					document.querySelector("#latex_content")
						.value = this.generateForCell(cell);
				}
			}
this.getHTML = (function(){
	var newline = false,
	_eqHTML = function(node, cont){
		if(node.nodeType == 3){
			cont.appendChild(node.cloneNode(true));
			if(!newline && /\S/.test(node.nodeValue)){
				newline = true;
			}
		}
		else if(node.nodeType == 1){
			var tagName = node.tagName, newnode;
			if(tagName == "B" || tagName == "I" || tagName == "UL" || tagName == "LI" || tagName == "U"){
				newnode = document.createElement(tagName);
				cont.appendChild(newnode);
			}
			else if(tagName == "FONT" && node.hasAttribute("color")){
				var ok = true;
				if(node.color == "#000000"){
					ok = false;
					// black is the default color. Let's check if there's another font tag, however this will pollute the DOM
						ok = false;
						var trav = cont;
						do{
							if(trav.tagName == "FONT"){
								ok = true;
								break;
							}
						}
						while(trav = trav.parentNode)
				}
				if(ok){
					newnode = document.createElement(tagName);
					newnode.color = node.color;
					cont.appendChild(newnode);
				}
			}
			else if(tagName == "STRONG"){
				newnode = document.createElement("B");
				cont.appendChild(newnode);
			}
			else if(tagName == "EM"){
				newnode = document.createElement("I");
				cont.appendChild(newnode);
			}
			else if(tagName.charAt(0) == "H" && /^\d$/.test(tagName.charAt(1))){
				// H1, H2, H3, H4, H5, H6
				if(newline){
					cont.appendChild(document.createElement("BR"));
				}
				newnode = document.createElement("B");
				cont.appendChild(newnode);
				cont.appendChild(document.createElement("BR"));
				newline = false;
			}
			else if(newline && (tagName == "DIV" || tagName == "P" || tagName == "HEADER" || tagName == "SECTION" || tagName == "FOOTER")){
				cont.appendChild(document.createElement("BR"));
				newline = false;
			}
			else if(tagName == "BR"){
				cont.appendChild(document.createElement("BR"));
				newline = false;
			}
			else if(node.className == "latex-equation"){
				newnode = document.createElement("span");
				newnode.className = "latex-equation";
				cont.appendChild(newnode);
				
			}
			else{
				var frag = document.createDocumentFragment(), lastnode;
				newnode = frag;
				cont.appendChild(frag);
				if(node.style.color){
					var color = toRGBA(node.style.color);
					if(color){
						// We need the HEX value of the color. However, HTML doesn't support alpha channel yet
						color = "#" + ((1 << 24) + (color[0] << 16) + (color[1] << 8) + color[2]).toString(16).slice(1);
						var ok = true;
						if(color == "#000000"){
							// black is the default color. Let's check if there's another font tag, however this will pollute the DOM
							ok = false;
							var trav = newnode;
							do{
								if(trav.tagName == "FONT"){
									ok = true;
									break;
								}
							}
							while(trav = trav.parentNode)
						}
						if(ok){
							lastnode = document.createElement("font");
							lastnode.color = color;
							newnode.appendChild(lastnode);
							newnode = lastnode;
						}
					}
				}
				if(node.style.fontWeight == "bold" || node.style.fontWeight == "bolder" || (+node.style.fontWeight)>= 700){
					lastnode = document.createElement("B");
					newnode.appendChild(lastnode);
					newnode = lastnode;
				}
				if(node.style.fontStyle == "italic" || node.style.fontStyle == "oblique"){
					lastnode = document.createElement("I");
					newnode.appendChild(lastnode);
					newnode = lastnode;
				}
				if(node.style.textDecoration && node.style.textDecoration.indexOf("underline")){
					lastnode = document.createElement("U");
					newnode.appendChild(lastnode);
					newnode = lastnode;
				}
				if(frag === newnode){
					newnode = null;
				}
			}
			for(var i=0;i<node.childNodes.length;i++){
				_eqHTML(node.childNodes[i], newnode || cont)
			}
		}
	}
	return function(cell, n){
		var div;
		if(cell.tagName == "TD" || cell.tagName == "TH"){
			if(!n){
				div = cell.querySelector("div[contenteditable]");
			}
			else{
				div = cell.querySelectorAll("div[contenteditable]")[n]
			}
		}
		else{
			div = cell;
		}
		if(div.innerText === "" && div.childNodes.length === 1 && div.firstChild.tagName == "BR"){
			// Fix this : https://connect.microsoft.com/IE/feedback/details/802442/ie11-rtm-implicit-br-tags-in-innerhtml-on-empty-content-editable-elements
			return "";
		}
		if(div.innerHTML.indexOf("<") == -1){
			// Shortcut for text-only cells (most cells)
			return div.innerHTML.replace(/\s*$/, "").replace(/^\s*/, "");
		}
		var cont = document.createElement("div");
		newline = false;
		for(var i=0;i<div.childNodes.length;i++){
			_eqHTML(div.childNodes[i], cont)
		}
		return cont.innerHTML.replace(/<\/(b|i)\s*>(\s*)<\s*(b|i)\s*>/gi, function(full, close, space, open){
			if(open.toLowerCase() == close.toLowerCase()){
				return space;
			}
			return full;
		});
	}
})();
			this.setHTML = function(cell, HTML) {
				cell.querySelector("div[contenteditable]")
					.innerHTML = HTML;
			}
			this.cellBefore = function(cell) {
				return cell.previousSibling;
			}
			this.blacklistPackages = {};
			this.isSelected = function(cell) {
				return cell.hasAttribute("data-selected");
			}
			this.lastSelectedCell = false;
			this.selectCell = function(element, CTRL, SHIFT) {
				if ((!CTRL && !SHIFT) || !this.lastSelectedCell) {
					this.removeAllSelection();
					this.showInfo(element);
					this.lastSelectedCell = this.selectedCell = element;
					element.setAttribute("data-selected", "data-selected");
				}
				else if (SHIFT) { //TODO
					var rows = this.element.rows, cells, startSelection = false;
					for(var i=0;i<rows.length;i++){
						cells = rows[i].cells;
						for(var j=0, cell;j<cells.length;j++){
							cell = cells[j];
							if(startSelection){
								if(cell === element || cell === this.lastSelectedCell){
									this.lastSelectedCell = element;
									// Hard break
									j = cells.length;
									i = rows.length;
								}
								cell.setAttribute("data-selected", "data-selected");
							}
							else if(cell === element || cell === this.lastSelectedCell){
								startSelection = true;
								element.setAttribute("data-selected", "data-selected");
							}
						}
					}
				} else {
					if (CTRL && element.hasAttribute("data-selected")) {
						element.removeAttribute("data-selected");
					} else {
						element.setAttribute("data-selected", "data-selected");
						this.lastSelectedCell = element
					}
				}
			}
			this._id = function(id) {
				return document.getElementById(id)
			}
			this.showInfo = function(element) {
				document.querySelector("#latex_content")
					.value = this.generateForCell(element);
				// Diagonal
				$id("info_diag_zero")
					.classList.remove("active");
				$id("info_diag_one")
					.classList.remove("active");
				$id("info_diag_two")
					.classList.remove("active");
				if (element.hasAttribute("data-two-diagonals")) {
					$id("info_diag_two")
						.classList.add("active");
				} else if (element.hasAttribute("data-diagonal")) {
					$id("info_diag_one")
						.classList.add("active");
				} else {
					$id("info_diag_zero")
						.classList.add("active");
				}
				// Align
				this._id("info_align_left")
					.classList.remove("active");
				this._id("info_align_center")
					.classList.remove("active");
				this._id("info_align_right")
					.classList.remove("active");
				var align = element.getAttribute("data-align");
				if (align == "c") {
					this._id("info_align_center")
						.classList.add("active");
				} else if (align == "r") {
					this._id("info_align_right")
						.classList.add("active");
				} else {
					this._id("info_align_left")
						.classList.add("active");
				}
				// Rotated ?
				if(element.hasAttribute("data-rotated")){
					this._id("info-rotated")
					.classList.add("active");
					this._id("info-unrotated").classList.remove("active")
				}
				else{
					this._id("info-unrotated").classList.add("active");
					this._id("info-rotated").classList.remove("active")
				}
				// Background color
				var color = element.style.backgroundColor || "#FFFFFF";
				color = toRGBA(color);
				color = "#" + ((1 << 24) + (color[0] << 16) + (color[1] << 8) + color[2]).toString(16).slice(1);
				this._id('info-background-color').value = color;
				
			}
			this.applyToCell = function(td) {

				var div1 = document.createElement("div");
				div1.className = "outer";
				var div2 = document.createElement("div");
				div2.contentEditable = true;
				div2.innerHTML = "";
				div1.appendChild(div2);
				td.appendChild(div1);
				td.addEventListener("click", this._clickCellManager, false);
				return td;
			}
			this.split = function() {
				this.statesManager.registerState();
				this.Table.split(document.querySelector("#table td[data-selected]"), this.applyToCell);
			}
			this.createCell = function(classNames) {
				var td = document.createElement("td");
				td.classNames = classNames || "";
				return this.applyToCell(td);
			}
			this.createRow = function(cols, classNames) {
				var tr = document.createElement("tr");
				for (var i = 0; i < cols; i++) {
					tr.appendChild(this.createCell(classNames));
				}
				return tr;
			}
			this.statesManager = new (function(table) {
				// A better undo manager is on the way;
				this.states = []
				this.registerState = function(){
					this.states.push(table.exportToJSON());
					this.stateNumber = this.states.length-1
				}
				this.stateNumber = 0;
				this.undo = function(){
					if (document.queryCommandEnabled("undo")) {
						document.execCommand("undo");
					}
					else if(this.states[this.stateNumber]){
						table.importFromJSON(this.states[this.stateNumber]);
						this.stateNumber--;
						this.states.pop();
					}
				}
			})(this)
			this.selectionAllowed = true;
			this.hasShownBorderEditorInfo = false;
			this.mode = function(n) {
				if (arguments.length == 0) {
					if (document.body.hasAttribute("data-view-editor")) {
						return 1
					}
					if (document.body.hasAttribute("data-border-editor")) {
						return 2
					}
					return 0;
				} else {
					$id("button-mode-edit")
						.classList.remove("active");
					$id("button-mode-border")
						.classList.remove("active");
					$id("button-mode-view")
						.classList.remove("active");
					$id("panel-draw-border")
						.classList.remove("active");
					$id("button-border-draw")
						.classList.remove("active");
					// Set
					if (n == 1 || n == 2) {
						var l = this.element.querySelectorAll("div[contenteditable]");
						for (var i = 0; i < l.length; i++) {
							(l[i] || {})
							.contentEditable = false;
						}
						this.selectionAllowed = false;
						if (n == 1) {
							// View
							document.body.removeAttribute("data-border-editor")
							document.body.setAttribute("data-view-editor", "data-view-editor");
							$id("button-mode-view")
								.classList.add("active");
						} else {
							// Border
							if (!this.hasShownBorderEditorInfo) {
								this.hasShownBorderEditorInfo = true;
								$("#border-editor-info")
									.show(100);
							}
							$("#right_border").collapse('show')
							document.body.removeAttribute("data-view-editor");
							document.body.setAttribute("data-border-editor", "data-border-editor");
							$id("button-mode-border")
								.classList.add("active");
							$id("panel-draw-border")
								.classList.add("active");
							$id("button-border-draw")
								.classList.add("active");
						}
					} else {
						// Edit
						document.body.removeAttribute("data-view-editor")
						document.body.removeAttribute("data-border-editor")
						this.selectionAllowed = true;
						var l = this.element.querySelectorAll("div[contenteditable]");
						for (var i = 0; i < l.length; i++) {
							(l[i] || {})
							.contentEditable = true
						}
						$id("button-mode-edit")
							.classList.add("active");
					}
					if(n != 2){
						// If we are not in the border editor, we hide information about it
						$("#border-editor-info").hide();
					}
				}
			}
			this.log = "";
			var logArchive = {};
			this.uniqueLog = function(text, type){
				if(!logArchive[text]){
					this.message(text, type);
				}
			}
			this.message = function(text, type) {
				if(type){
					type=type.toString().toLowerCase();
				}
				else{type = "";}
				if(this.log == ""){
					logArchive = {};
				}
				logArchive[text] = true;
				if(type == "warning" || type == "1"){
					this.log += "<table><tr><td><span class='glyphicon glyphicon-exclamation-sign' style='padding-right:4px;'></span></td><td>"+text+"</td><tr></table><hr>";
				}
				else{
					this.log += "<p class='"+type+"'>"+text+"</p><hr>";
				}
			}
			this.importFromJSON = function(o) {
				if (o.autoBooktabs) {
					this.element.setAttribute("data-booktabs", "data-booktabs");
					$id("button-booktabs")
						.classList.add("active");
				} else {
					this.element.removeAttribute("data-booktabs");
					$id("button-booktabs")
						.classList.remove("active");
				}
				if (o.options){
					for(var i in o.options){
						var elem = $id("opt-"+i);
						if(o.options.hasOwnProperty(i) && elem){
							if(elem.type == "radio" || elem.type == "checkbox"){
								elem.checked = o.options[i];
							}
							else{
								elem.value = o.options[i];
							}
						}
					}
				}
				if (o.caption) {
					if (o.caption.numbered) {
						$id("caption-nb")
							.value = "*";
					}
					$id("caption")
						.value = o.caption.caption || "";
					$id("label")
						.value = o.caption.label || "";
				}
				var table = document.createDocumentFragment();
				for (var i = 0; i < o.cells.length; i++) {
					var row = o.cells[i],
						elem = document.createElement("tr");
					for (var j = 0; j < row.length; j++) {
						var cellO = row[j];
						var cell = document.createElement("td");
						cell = this.applyToCell(cell);
						if (cellO.dataset.twoDiagonals){
							var div = cell.querySelector(".outer")
							div.innerHTML = "<div contenteditable>" + cellO.html[0] + "</div><div contenteditable>"
									+ cellO.html[1] + "</div><div contenteditable>" + cellO.html[2] + "</div>";
						}
						else if (cellO.dataset.diagonal) {
							cell.querySelector(".outer")
								.innerHTML += "<div contenteditable>" + cellO.html[1] +
								"</div>";
							this.setHTML(cell, cellO.html[0]);
						} else {
							this.setHTML(cell, cellO.html);
						}
						for (var k in cellO.dataset) {
							if (cellO.dataset.hasOwnProperty(k)) {
								cell.dataset[k] = cellO.dataset[k];
							}
						}
						if ("rowSpan" in cellO && cellO.rowSpan > 1) {
							cell.rowSpan = cellO.rowSpan;
						}
						if (cellO.colSpan && cellO.colSpan > 1) {
							cell.colSpan = cellO.colSpan;
						}
						if (cellO.css) {
							cell.style.cssText = cellO.css;
						}
						elem.appendChild(cell);
					}
					table.appendChild(elem);
				}
				while (this.element.firstChild) {
					this.element.removeChild(this.element.firstChild);
				}
				this.element.appendChild(table);
			}
			this.exportToJSON = function() {
				var o = {options:{}},
					table = this.element;
				o.autoBooktabs = table.hasAttribute("data-booktabs");
				o.caption = this.caption();
				o.cells = [];
				var options = document.querySelectorAll("*[id^='opt-']");
				for( var i = 0,option; i < options.length;i++){
					option = options[i];
					o.options[option.id.substring(option.id.indexOf("-")+1)] = (option.type == "radio" || option.type == "checkbox") ? option.checked : option.value;
				}
				for (var i = 0; i < table.rows.length; i++) {
					var cells = table.rows[i].cells;
					o.cells.push([]);
					for (var j = 0; j < cells.length; j++) {
						var cell = cells[j],
							cellO = {dataset:{}};
						for(var prop in cell.dataset){
							if(cell.dataset.hasOwnProperty(prop)){
								cellO.dataset[prop] = cell.dataset[prop]
							}
						}
						if (cell.dataset.twoDiagonals){
							cellO.html = [this.getHTML(cell), this.getHTML(cell, 1), this.getHTML(cell, 2)]
						}
						else if (cell.dataset.diagonal) {
							cellO.html = [this.getHTML(cell), this.getHTML(cell, 1)]
						} else {
							cellO.html = this.getHTML(cell);
						}
						if (cellO.dataset.selected) {
							delete cellO.dataset.selected;
						}
						cellO.css = cell.style.cssText;
						cellO.rowSpan = cell.rowSpan;
						cellO.colSpan = cell.colSpan;
						o.cells[o.cells.length - 1].push(cellO);
					}
				}
				o.version = this.version;
				return o;
			}
			this.importCSV = function(text){
				function createObject(str){
					var o = {}, div = document.createElement("div");
					div.innerText = div.textContent = str;
					o.html = div.innerHTML.replace(/\n/g, "<br>");
					return o;
				}

				text = text.replace(/^[\n\r]+/, "").replace(/[\n\r]+$/, "") + "\n";
				var table = [],
				row = [],
				indbl = false,
				start = true,
				content = "";
				for(var i=0, c;i<text.length;i++){
					c = text.charAt(i);
					if(start){
						start = false;
						if(c == '"'){
							indbl = true;
						}
						else{
							content += c;
						}
					}
					else if(c == '"' && indbl){
						if(text.charAt(i+1) == '"'){
							i++;
							content += c;
						}
						else{
							indbl = false;
						}
					}
					else if(c == "," && !indbl){
						row.push(createObject(content));
						indbl = false;
						content = "";
						start = true
					}
					else if(c == "\n" && !indbl){
						row.push(createObject(content));
						indbl = false;
						content = "";
						start = true
						table.push(row);
						row = [];
					}
					else{
						content += c;
					}
				}
				return {
					autoBooktabs : false,
					caption: {
       						caption: "",
        					numbered: false,
       			 			label: ""
    					},
					cells: table
				}
			};
			this.insertEquation = function() {
				if (window.getSelection) {
					var sel = window.getSelection();
					if (sel.rangeCount) {
						var range = sel.getRangeAt(0);
						if (range) {
							var eq = document.createElement("span");
							eq.className = "latex-equation";
							eq.appendChild(range.extractContents())
							range.insertNode(eq);
							range.selectNodeContents(eq);
						}
					}
				}
			}
			this.saveToJSON = function() {
				var o = this.exportToJSON();
				document.getElementById('c')
					.value = JSON.stringify(o, null, "    ");
			}
			this.autoBooktabs = function() {
				this.statesManager.registerState();
				var table = this.element;
				if (table.hasAttribute("data-booktabs")) {
					table.removeAttribute("data-booktabs");
					$id('button-booktabs')
						.className = "btn btn-default";
				} else {
					table.setAttribute("data-booktabs", "data-booktabs");
					$id('button-booktabs')
						.className = "btn btn-default active";
				}
			}
			this._clickCellManager = function(event) {
				if (table.selectionAllowed) {
					table.selectCell(this, event.ctrlKey, event.shiftKey);
				}
			}
			this.isBorderSet = function(element, where){
				return element.getAttribute("data-border-" + where.toLowerCase()) == document.getElementById('border').value
			}
			this.setBorder = function(element, where, affect){
				this.statesManager.registerState();
				where = where.toLowerCase();
				var where2 = where.charAt(0).toUpperCase() + where.substring(1),
				border = this.borderStyle();
				if(affect){
					element.setAttribute("data-border-" + where, border.name);
					element.style["border" + where2] = border.css;
				}
				else if(element.style.removeProperty){
					element.removeAttribute("data-border-" + where);
					element.style.removeProperty("border-" + where);
				}
				else{
					element.removeAttribute("data-border-" + where);
					element.style["border" + where2] = "";
				}
			}
			this.borderStyle = function(style){
				style = (style || document.getElementById('border').value).toLowerCase();
				var color = this._id("border-color").value;
				var css = "1px solid " + color;
				if(style == "toprule" || style == "bottomrule"){
					css = "2px solid " + color;
				}
				else if(style == "double"){
					css = "2px double " + color;
				}
				else if(style == "hdashline"){
					css = "1px dashed " + color;
				}
				else if(style == "dottedline"){
					css = "1px dotted " + color;
				}
				else if(style == "trimfull"){
					css = "";
				}
				
				return {
					name : style,
					css : css,
					color : color
				}
			}
			this.setAllBorders = function() {
				this.statesManager.registerState();
				var borderType = document.getElementById('border')
					.value,
					color = this._id("border-color").value,
					border = "1px solid " + color;
				if (borderType == "toprule" || borderType == "bottomrule") {
					border = "2px solid " + color;
				} else if (borderType == "double") {
					border = "2px double " + color;
				} else if (borderType == "hdashline") {
					border = "1px dashed " + color;
				} else if (borderType == "dottedline") {
					border = "1px dotted " + color;
				}
				this.forEachSelectedCell(function(cell) {
					var style = cell.style;
					style.borderTop = style.borderLeft = style.borderRight = style.borderBottom = border;
					cell.setAttribute("data-border-top", borderType);
					cell.setAttribute("data-border-left", borderType);
					cell.setAttribute("data-border-right", borderType);
					cell.setAttribute("data-border-bottom", borderType);
				});
			}
			this.removeBorders = function() {
				this.statesManager.registerState();
				this.forEachSelectedCell(function(cell) {
					var style = cell.style;
					style.borderTop = style.borderLeft = style.borderRight = style.borderBottom = "";
					cell.removeAttribute("data-border-top");
					cell.removeAttribute("data-border-left");
					cell.removeAttribute("data-border-right");
					cell.removeAttribute("data-border-bottom");
				});
			}
			this._absolutePosition = function(el) {
				// Stolen from here : https://stackoverflow.com/a/32623832/8022172
				var found,
					left = 0,
					top = 0,
					width = 0,
					height = 0,
					offsetBase = this._absolutePosition.offsetBase;
				if (!offsetBase && document.body) {
					offsetBase = this._absolutePosition.offsetBase = document.createElement('div');
					offsetBase.style.cssText = 'position:absolute;left:0;top:0';
					document.body.appendChild(offsetBase);
				}
				if (el && el.ownerDocument === document && 'getBoundingClientRect' in el && offsetBase) {
					var boundingRect = el.getBoundingClientRect();
					var baseRect = offsetBase.getBoundingClientRect();
					found = true;
					left = boundingRect.left - baseRect.left;
					top = boundingRect.top - baseRect.top;
					width = boundingRect.right - boundingRect.left;
					height = boundingRect.bottom - boundingRect.top;
				}
				return {
					found: found,
					left: left,
					top: top,
					width: width,
					height: height,
					right: left + width,
					bottom: top + height
				};
			}
			this.defineBorder = function(element, where){	
				var borderType = document.getElementById('border').value,
					border = "1px solid black";
				if (borderType == "toprule" || borderType == "bottomrule") {
					border = "2px solid black";
				} else if (borderType == "double") {
					border = "2px double black";
				} else if (borderType == "hdashline") {
					border = "1px dashed black";
				} else if (borderType == "dottedline") {
					border = "1px dotted black";
				}
				where = where.toLowerCase();
				where = where.charAt(0).toUpperCase() + where.substring(1);
				this.setBorder(element, where, borderType, border, true)
			}
			this.editBorder = function(element, x, y) {
				var pos = this._absolutePosition(element),
					borderType = document.getElementById('border')
					.value,
					border = "1px solid black";
				if (borderType == "toprule" || borderType == "bottomrule") {
					border = "2px solid black";
				} else if (borderType == "double") {
					border = "2px double black";
				} else if (borderType == "hdashline") {
					border = "1px dashed black";
				} else if (borderType == "dottedline") {
					border = "1px dotted black";
				}
				if (y - pos.top < 4) {
					this.setBorder(element, "top", !this.isBorderSet(element, "top"));
				} else if (pos.bottom - y < 4) {
					this.setBorder(element, "bottom", !this.isBorderSet(element, "bottom"));
				} else if (x - pos.left < 4) {
					this.setBorder(element, "left", !this.isBorderSet(element, "left"));
				} else if (pos.right - x < 4) {
					this.setBorder(element, "right", !this.isBorderSet(element, "right"));
				}
			}
			this.loaded = false;
			this.element = null;
			this.load = function(table) {
				this.loaded = true;
				this.element = table;
				var _this = this,
				waitingforpaste = false;
				table.addEventListener("paste", function(e) {
					console.log(1);
					var target = e.target || e.srcElement;
					target = target.nodeType == 3 ? target.parentElement : target;
					do{
						if(target.tagName && target.hasAttribute("contenteditable")){
							break;
						}
					}while(target = target.parentElement);
					waitingforpaste = target;
				}, false);
				table.addEventListener("input", function(e) {
					var target = e.target || e.srcElement;
					target = target.nodeType == 3 ? target.parentElement : target;
					if(target && target == waitingforpaste){	
						waitingforpaste = false;
						target.innerHTML = _this.getHTML(target);
					}
					if (_this.selectedCell === (target.parentElement || {})
						.parentElement) {
						_this.updateLaTeXInfoCell();
					}
					var td = (target.parentElement || {}).parentElement;
					if(td.hasAttribute("data-rotated")){
						_this.refreshRotatedCellSize(td)
					}
				}, false);
				table.addEventListener("click", function(e) {
					var target = e.currentTarget;
					if (target.tagName == "TD" || target.tagName == "TH") {
						_this._clickCellManager.apply(this, arguments);
					}
				}, false);



				document.execCommand("styleWithCSS", false, false);
				document.execCommand("insertBrOnReturn", false, false);
				this.Table = new Table(table);
			}
			this.refreshRotatedCellSize = function(td){
				// - Get the width and set it as the height
				// - To get the width, we are gonna set a range around its content
				//   and get its size
				var range = document.createRange();
				range.selectNodeContents(td.querySelector("div[contenteditable]"));
				var size = range.getBoundingClientRect();
				range.detach() // We don't need the range anymore
				td.style.height=(size.width+6)+"px";
				td.style.width=(size.height+6)+"px";
			}
			this.generateFromHTML = function(html, ignoreMultiline, align) {
				align = align || "l";
				var div = document.createElement("div"), hasMultiline;
				div.innerHTML = html;
				var el = div.querySelectorAll("span.latex-equation");
				var eq = []
				for (var i = 0; i < el.length; i++) {
					var kbd = document.createElement("kbd");
					eq.push("$" + (el[i].innerText || el[i].textContent) + "$");
					el[i].parentNode.replaceChild(kbd, el[i]);
				}
				var ul = div.querySelectorAll("ul");
				var ULs = []
				for (var i = 0; i < ul.length; i++) {
					var uli = ul[i];
					var ins = document.createElement("ins"),
					    li = ul[i].querySelectorAll("li"),
					    lis = [];
					for(var j=0;j<li.length;j++){
						var liHTML = li[j].innerHTML, continueWhile = true;
						// Let's remove weird <br> tags at the end of <li>
						// TODO : Move this to the function that normalize HTML (getHTML)
						while(continueWhile){
							if(/<br\s*\/?\s*>$/i.test(liHTML)){
								liHTML = liHTML.replace(/<br\s*\/?\s*>$/i,"");
							}
							else{
								continueWhile = false;
							}
						}
						lis.push(this.generateFromHTML(liHTML, false, align));
					}
					if(align.charAt(0) == "p"){
						ULs.push("\\begin{tabular}{@{}>{\\textbullet\\hspace{\\labelsep}}"+align+"}"
							+lis.join("\\\\")+"\\end{tabular}");
						this.packages["array"] = true;
					}
					else{
						ULs.push("\\begin{tabular}{@{\\textbullet\\hspace{\\labelsep}}"+align+"}"
							+lis.join("\\\\")+"\\end{tabular}");
					}
					while(uli.firstChild){
						uli.removeChild(uli.firstChild);
					}
				}
				html = div.innerHTML;
				var str = "", kbdcount = 0, ulcount = 0, lastcrcr = -1,
				useColor = !this.blacklistPackages["color"],
				useU = !this.blacklistPackages["ulem"];
				for(var i=0,c;i<html.length;i++){
					c = html.charAt(i);
					if(c == "<"){
						var inside = html.substring(i, html.indexOf(">", i+1)+1),
						tagname = /^<?\s*\/?\s*([a-z]+)/i.exec(inside)[1].toLowerCase();
						if(/^<?\s*\//.test(inside)){tagname="/"+tagname;}
						if(tagname == "br"){
							hasMultiline = true;
							str += "\\\\";
						}
						else if(tagname == "kbd"){
							str += eq[kbdcount];
							kbdcount++;
						}
						else if(tagname == "ul"){
							if(str.length > 0){
								str += "\\\\"
								hasMultiline = true;
							}
							str += ULs[ulcount] + "\\\\";
							lastcrcr = str.length;
							ulcount++;
							
						}
						else if(tagname == "b"){
							str += "\\textbf{";
						}
						else if(tagname == "i"){
							str += "\\textit{";
						}
						else if(tagname == "u" && useU){
							this.packages["ulem"] = true;
							str+="\\uline{";
						}
						else if(tagname == "font" && useColor){
							var color = /color\s*=\s*["']?(#?[a-f0-9]+)/i.exec(inside);
							if(color){
								color = color[1];
								if(color){
									this.packages["color"] = true;
									str += "\\textcolor"+getColor(color)+"{"
								}
								else{
									str += "{";
								}
							}
							else{str += "{"}
						}
						else if(tagname == "/b" || tagname == "/i" || (tagname == "/font" && useColor)){
							str += "}";
						}
						else if(tagname == "/u" && useU){
							str += "}";
						}
						i += inside.length-1;
						continue;
					}
					else if(c == "&"){
						var inside = html.substring(i, html.indexOf(";", i+1)+1);
						if(inside == "&nbsp;"){
							str += "~";
						}
						else if(inside == "&lt;"){
							str += "<";
						}
						else if(inside == "&amp;"){
							str += "\\&";
						}
						else if(inside == "&quot;"){
							str += '"';
						}
						i += inside.length-1;
					}
					else if(c == "\\"){
						str += "\\textbackslash{}";
					}
					else if(c == "$" || c == "%" || c == "^" || c == "_" || c == "{" || c == "}" || c == "#"){
						str += "\\" + c;
					}
					else if(c == "|"){
						str += "\\textbar{}";
					}
					else if(c.charCodeAt(0)==182){
						str += "\\P{}";
					}
					else if(c == "~"){
						str += "\\textasciitilde{}";
					}
					else{
						str+= c;
					}
				}
				if(str.length == lastcrcr){
					str = str.slice(0,-2);
				}
				str = str.replace(/[ ]{2,}/g, " ")
					.replace(/[\n\r]+/g, "");
				if ((hasMultiline || str.indexOf("\\\\") > -1) && !ignoreMultiline) {
					str = "\\begin{tabular}[c]{@{}"+ align +"@{}}" + str + "\\end{tabular}";
				}
				return str
			};

			this.generateForCell = function(cell, align, shrinkRatio) {
				align = align || "l";
				var text = "";
				if (cell.hasAttribute("data-two-diagonals")) {
					this.packages["diagbox"] = true;
					text = "\\diagbox{" + this.generateFromHTML(this.getHTML(cell, 2)) + "}{" + this.generateFromHTML(this.getHTML(cell)) + "}{" +
						this.generateFromHTML(this.getHTML(cell, 1)) + "}"
				} else if (cell.hasAttribute("data-diagonal")) {
					var ce = cell.querySelectorAll("div[contenteditable]");
					if (this.blacklistPackages["diagbox"]) {
						this.packages["slashbox"] = true;
					} else {
						this.packages["diagbox"] = true;
					}
					text = "\\backslashbox{" + this.generateFromHTML(this.getHTML(cell)) + "}{" + this.generateFromHTML(this.getHTML(cell, 1)) + "}";
				} else if (cell.hasAttribute("data-rotated")) {
					if (cell.rowSpan > 1) {
						if (this.blacklistPackages["makecell"]) {
							var inside = this.generateFromHTML(this.getHTML(cell), true, align)
								this.message("You may have to adjust the following value in one of your rotated cell : \"" + (cell.rowSpan) + "\\normalbaselineskip\"", "warning");
								text = "\\begin{sideways}\\begin{tabular*}{" + 
									cell.rowSpan + "\\normalbaselineskip}{"+align+"}"
									+ inside +
									"\\end{tabular*}\\end{sideways}";
								this.packages["rotating"] = true;
						} else {
							text = "\\rotcell{" + this.generateFromHTML(this.getHTML(cell), false, align) + "}"
							this.packages["makecell"] = true;
						}
					} else {
						if (this.blacklistPackages["rotating"]) {
							text = "\\rotcell{" + this.generateFromHTML(this.getHTML(cell), false, align) + "}"
							this.packages["makecell"] = true;
						} else {
							text = "\\begin{sideways}" + this.generateFromHTML(this.getHTML(cell), false, align) + "\\end{sideways}"
							this.packages["rotating"] = true;
						}
					}
				} else if (cell.rowSpan > 1 && (!this.blacklistPackages["makecell"] || this.shrink) && !this.blacklistPackages["multirow"]) {
						text = this.generateFromHTML(this.getHTML(cell), true, align);
						if(this.blacklistPackages["makecell"]){
							text = text.replace(/\\{4,}/g, function(full){
								var after = "", str = "", nb = full.length;
								if(nb % 2 == 1){
									after = "\\";
									nb--;
								}
								for(var i=0;i<nb;i=i+2){
									str += "\\\\";
									if(i+2<nb){
										str+= "~";
									}
								}
								return str + after;
							});
						}
					
				} else if(this.shrink){
					text = this.generateFromHTML(this.getHTML(cell), true, align).replace(/\\{4,}/g, function(full){
						var after = "", str = "", nb = full.length;
						if(nb % 2 == 1){
							after = "\\";
							nb--;
						}
						for(var i=0;i<nb;i=i+2){
							str += "\\par";
							if(i+2<nb){
								str+= "\\null";
							}
							else{
								str += "{}";
							}
						}
						return str + after;
					});
				}
				else{
					text = this.generateFromHTML(this.getHTML(cell), false, align);
				}
				return text;
			}
			this.packages = {};
			this.getHeaderForCell = function(cell) {
				var align = cell.getAttribute("data-align") || "l",
					leftBorder = cell.getAttribute("data-border-left") || "",
					rightBorder = cell.getAttribute("data-border-right") || "",
					o = {
						"": "",
						"normal": "|",
						"double": "||",
						"toprule": "!{\\vrule width \\heavyrulewidth}",
						"midrule": "!{\\vrule width \\lightrulewidth}",
						"bottomrule": "!{\\vrule width \\heavyrulewidth}",
						"hdashline": ":",
						"dottedline": ";{1pt/1pt}"
					}
				leftBorder = o[leftBorder] || "";
				rightBorder = o[rightBorder] || "";
				return leftBorder + align + rightBorder
			}
			this.getSimiliHeaderForCell = function(cell) {
				var align = cell.getAttribute("data-align") || "l",
					leftBorder = cell.getAttribute("data-border-left") || "",
					rightBorder = cell.getAttribute("data-border-right") || "",
					o = {
						"": "",
						"normal": "|",
						"double": "=",
						"toprule": "^",
						"midrule": "#",
						"bottomrule": "_",
						"hdashline": ":",
						"dottedline": ";"
					}
				leftBorder = o[leftBorder] || "";
				rightBorder = o[rightBorder] || "";
				return leftBorder + align + rightBorder
			}
			this.toggleExecCommand = function(command, value){
				var sel = window.getSelection();
				if(this.element.querySelectorAll("td[data-selected]").length <= 1){
					return document.execCommand(command, false, value || null);
				}
				else{
					var foundFirst = false,
					state = null;
					sel.removeAllRanges();
					this.forEachSelectedCell(function(cell){
						setTimeout(function(){
							var node = cell.querySelector("div[contenteditable]");
							sel.selectAllChildren(node);
							if(!foundFirst){
								foundFirst = true;
								state = !document.queryCommandEnabled(command);
								document.execCommand(command, false, null);
							}
							else{
								if(document.queryCommandEnabled(command) == state){
									document.execCommand(command, false, null);
								}
								document.execCommand(command, false, null);
							}
							sel.removeAllRanges();
						}, 1);
					});
					return state;
				}
			}
			this.createCellO = function(o, row){
				var before = null,
				    after = null,
				    cell = o.cell,
				    blockMultirow = this.blacklistPackages["multirow"];
				// find real Before
				for(var i=o.x-1;i>=0;i--){
					var before2 = row[i];
					if(!before2.refCell || before2.refCell != (o.refCell || o)){
						before = before2;break;
					}
				}
				// find real After
				for(var i=o.x+1;i<row.length;i++){
					var after2 = row[i];
					if(!after2.refCell || after2.refCell != (o.refCell || o)){
						after = after2;break;
					}
				}
				o.align = cell.getAttribute("data-align") || "l"
				o.content = this.generateForCell(cell, o.align);
				o.getHeader = this.comparableHeader(before, o, after);
				o.header = o.getHeader(this.actualMainColor);
				o.span = (cell.rowSpan != 1 || cell.colSpan != 1);
				o.static = false;
				o.isInPreambule = false;
				o.switch = false; // Is it a rowspan cell with a background color ?
				o.rowSpan = cell.rowSpan;
				o.colSpan = cell.colSpan;
				o.fullContent = o.content;
				o.background = false;
				var _this = this;
				// Determine background
				var background = cell.style.backgroundColor;
				if(!this.blacklistPackages["colortbl"]){
					if(background && !(background == "transparent" || background == "initial" || background == "inherit")){
						background = toRGBA(background);
						if(background && background[3] > 0){
							if(!(background[0] == 255 && background[1] == 255 && background[2] == 255)){
								// We have a non-white non-transparent background
								o.background = background;
								if(o.rowSpan > 1){
									o.switch = true;
								}
							}						
						}
					}
				}
				o.getFullContent = function(actualColor, forceMulti){
					var header = "", before = "",
					content = o.content;
					actualColor = actualColor || _this.actualColor;
					// Set background
					if(cell.rowSpan != 1 && !blockMultirow){
						_this.packages["multirow"] = true;
						if(_this.blacklistPackages["makecell"] || (_this.shrink || o.shrinkRatio)) {
							var alignment = "";
							if(o.align == "c"){
								if(_this.blacklistPackages["ragged2e"]){
									alignment = "\\centering\\arraybackslash{}";
								}
								else{
									alignment = "\\Centering{}";
									_this.packages["ragged2e"] = true;
								}
							}
							else if(o.align == "r"){
								if(_this.blacklistPackages["ragged2e"]){
									alignment += "\\raggedleft\\arraybackslash{}";
								}
								else{
									alignment += "\\RaggedLeft{}";
									_this.packages["ragged2e"] = true;
								}
							}
							content = alignment + content;
						}
						if(!_this.blacklistPackages["makecell"]) {
							if(_this.shrink && o.shrinkRatio){
								content = "\\makecell[{{p{"+o.shrinkRatio+"\\columnwidth}}}]{" + content + "}";
							}
							else{
								content = "\\makecell["+o.align+"]{" + content + "}";
							}
							_this.packages["makecell"] = true;
						}
						if(o.background){
							_this.packages["colortbl"] = true;
							content="{\\cellcolor"+getColor(o.background)+"}"+content;
						}
						var ratio = o.switch ? -1 : 1;
						if(_this.shrink){
							content = _this.multirow(ratio*cell.rowSpan, content, o.shrinkRatio+"\\columnwidth");
						}
						else{
							content = _this.multirow(ratio*cell.rowSpan, content);
						}
					}
					else if(o.background){
						_this.packages["colortbl"] = true;
						content="{\\cellcolor"+getColor(o.background)+"}"+content;
					}
					if(cell.colSpan != 1 || forceMulti || !o.isInPreambule){
						header = o.getHeader(actualColor);
						if(header.charAt(0) == "@"){
							header = header.replace(/^@\{[^{]+\{[\s,]*([\d.]+)[\s,]*([\d.]+)[\s,]*([\d.]+)\s*}\s*}/, function(full, r, g, b){
								var r2 = r*255,
								g2 = g*255,
								b2 = b*255,
								color = "rgb("+r2+","+g2+","+b2+")";
								_this.actualColor = color;
								before = "\\arrayrulecolor" + getColor(color);
								return "";
							});
						}
						return before + _this.multicolumn(cell.colSpan, header, content);						
					}
					else{
						return content;
					}
				}
			}
			this.multicolumn = function(span, header, content){
				return "\\multicolumn{"+span+"}{" + header + "}{" + content + "}";
			}
			this.multirow = function(span, content, width){
				width = width || "*";
				return "\\multirow{"+span+"}{"+width+"}{"+content+"}";
			}
			this.matrix = function(){
				var table = this.element,
				    result = this.Table.matrix();
				for(var i=0;i<result.length;i++){
					var row = result[i];
					for(var j=0;j<row.length;j++){
						var cell = row[j];
						if(!cell.refCell){
							this.createCellO(cell, row);
						}
						else if(cell.refCell.x == cell.x){
							// ROWSPAN
							var refCell = cell.refCell;
							cell.ignore = false;
							cell.header = refCell.header;
							cell.getHeader = refCell.getHeader
							var _this = this;
							cell.getFullContent = (function(cell, refCell){
								return function(actualColor, forceMulti){
									actualColor = actualColor || _this.actualColor;
									var content = "";
									if(refCell.background){
										content = "{\\cellcolor"+getColor(refCell.background)+"}";
									}
									if(refCell.colSpan != 1 || forceMulti || !refCell.isInPreambule){
										return _this.multicolumn(refCell.colSpan, cell.getHeader(actualColor), content)
									}
									return content;
								}
							})(cell, refCell);
						}
						else{
							// COLSPAN
							cell.ignore = true;
						}
					}
				}
				return result;
			}
			this.buildBlacklist = function() {
				var o = {},
					check = document.querySelectorAll("input[type=checkbox][id^=blacklist]");
				for (var i = 0; i < check.length; i++) {
					if (!check[i].checked) {
						o[check[i].value] = true;
					}
				}
				this.blacklistPackages = o;
				return o;
			}
			this.removeRow = function() {
				this.statesManager.registerState();
				if (this.selectedCell) {
					this.Table.removeRow(this.selectedCell.parentElement.rowIndex);
				}
				if(!this.selectedCell || !this.selectedCell.parentElement){
					this.selectedCell = null;
				}
			}
			this.removeCol = function() {
				this.statesManager.registerState();
				if (this.selectedCell) {
					this.Table.removeCol(this.Table.position(this.selectedCell).x);
				}
				if(!this.selectedCell || !this.selectedCell.parentElement){
					this.selectedCell = null;
				}
			}
			this.caption = function() {
				return {
					caption: $id("caption")
						.value,
					numbered: $id("caption-nb")
						.value == "*",
					label: $id("label")
						.value
				}
			}
			this.headerBorder = function(type, color, mainColor, preambule, char){
				char = char || ">";
				if(color && mainColor){
					if(areSameColors(color, mainColor)){
						color = false;
					}
				}
				if(!color){
					if(type == "normal"){return "|"}
					else if(type == "double"){return "||"}
					else if(type == "toprule" || type == "bottomrule"){
						return "!{\\vrule width \\heavyrulewidth}";
					}
					else if(type == "midrule"){
						return "!{\\vrule width \\lightrulewidth}";
					}
					else if(type == "hdashline"){
						if(this.useTabu){
							return "|[on 4pt off 4pt]";
						}
						else{
							this.packages["arydshln"] = true;
							return ":";
						}
					}
					else if(type == "dottedline"){
						if(this.useTabu){
							return "|[on 1pt off 1pt]";
						}
						else{
							this.packages["arydshln"] = true;
							return ";{1pt/1pt}";
						}
					}
				}
				else{
					var before = "",
					colorcomm = "\\color" + getColor(color);
					if(type == "normal"){
						if(this.useTabu){
							return "|["+this.tabuColor(color)+"]"
						}
						else{
							return "!{"+colorcomm+"\\vrule}"
						}
					}
					else if(type == "double"){
						if(this.useTabu){
							return "|["+this.tabuColor(color)+"]|["+this.tabuColor(color)+"]"
						}
						else{
							return "!{"+colorcomm+"\\vrule}!{"+colorcomm+"\\vrule}"
						}
					}
					else if(type == "toprule" || type == "bottomrule"){
						return "!{"+colorcomm+"\\vrule width \\heavyrulewidth}";
					}
					else if(type == "midrule"){
						return "!{"+colorcomm+"\\vrule width \\lightrulewidth}";
					}
					else if(type == "hdashline"){
						before = char + "{\\arrayrulecolor"+getColor(color)+"}"
						if(this.useTabu){
							return "|["+this.tabuColor(color)+" on 4pt off 4pt]";
						}
						else{
							this.packages["arydshln"] = true;
							return before + ":";
						}
					}
					else if(type == "dottedline"){
						before = char + "{\\arrayrulecolor"+getColor(color)+"}"
						if(this.useTabu){
							return "|["+this.tabuColor(color)+" on 1pt off 1pt]";
						}
						else{
							this.packages["arydshln"] = true;
							return before + ";{1pt/1pt}";
						}
					}
				}
			}
			this.comparableHeader = function(before, middle, after) {
				if (before) {
					before = before.cell || before.refCell.cell;
				}
				if (after) {
					after = after.cell || after.refCell.cell;
				}
				var align = middle.align,
					leftBorder = "",
					rightBorder = "",
					leftColor = "",
					rightColor = "",
					incorrectLeft = false,
					o = middle;
				middle = middle.cell || middle.refCell.cell;
				if (before) {
					leftBorder = "";
				} else {
					leftBorder = middle.getAttribute("data-border-left");
					leftColor = middle.style.borderLeftColor || "black";
				}
				rightBorder = middle.getAttribute("data-border-right");
				rightColor = middle.style.borderRightColor;
				var between = "";
				if (after && !rightBorder) {
					rightBorder = after.getAttribute("data-border-left");
					rightColor = after.style.borderLeftColor;
				}
				o.leftBorder = leftBorder || "";
				o.leftBorderColor = leftColor;
				o.rightBorder = rightBorder || "";
				o.rightBorderColor = rightColor;
				var _this = this;
				return function(color, isPreambule){
					var preambule = "",
					align2 = align,
					shrinkRatio = o.shrinkRatio;
					if(leftBorder){
						leftColor = leftColor || "#000000";
						preambule += _this.headerBorder(leftBorder, leftColor, color, isPreambule, "@");
						if(preambule.charAt(0) == "@"){
							color = leftColor;
							if(isPreambule){
								_this.actualColor = rightColor;
							}
						}
					}
					var before = "";
					if(shrinkRatio){
						var blockragged = _this.blacklistPackages["ragged2e"];
						if(align == "c"){
							if(_this.packages["ragged2e"]){
								before += "\\Centering"
							}
							else{
								before += "\\centering\\arraybackslash"
							}
						}
						else if(align == "r"){
							if(blockragged){
								before += "\\raggedleft\\arraybackslash"
							}
							else{
								_this.packages["ragged2e"] = true;
								before += "\\RaggedLeft"
							}
						}
						align2 = "p{"+shrinkRatio+"\\columnwidth}";
					}
					if(rightBorder){
						rightColor = rightColor || "#000000";
						if(isPreambule && _this.packages["arydshln"] && !areSameColors(color, _this.actualMainColor) && areSameColors(_this.actualMainColor, rightColor)){
							_this.actualColor = color = rightColor;
							before += "\\arrayrulecolor"+getColor(rightColor);
						}
						else if(rightBorder == "dottedline" || rightBorder == "hdashline"){
							if(!areSameColors(rightColor, color)){
								if(_this.useTabu){
									_this.uniqueLog("Some vertical lines could not be colored correctly with 'tabu' package.", "warning");
								}
								else{
									preambule += "\\arrayrulecolor"+getColor(rightColor);
									color = rightColor;
									if(isPreambule){
										_this.actualColor = rightColor;
									}
								}
							}
						}
					}
					if(before){
						preambule += ">{"+before+"}";
						_this.packages["array"] = true;
					}
					preambule += align2;
					if(rightBorder){
						preambule += _this.headerBorder(rightBorder, rightColor, color, isPreambule, ">")
					}
					return preambule;
				};

			}
			this.getComparableHeader = function(before, middle, after) {
				if (before) {
					before = before.cell || before.refCell.cell;
				}
				if (after) {
					after = after.cell || after.refCell.cell;
				}
				var align = middle.align,
					leftBorder = "",
					rightBorder = "",
					o = {
						"": "",
						"normal": "|",
						"double": "=",
						"toprule": "^",
						"midrule": "#",
						"bottomrule": "_",
						"hdashline": ":",
						"dottedline": ";"
					};
				middle = middle.cell || middle.refCell.cell;
				if (before) {
					leftBorder = "";
				} else {
					leftBorder = middle.getAttribute("data-border-left");
				}
				leftBorder = o[leftBorder || ""] || "";
				rightBorder = middle.getAttribute("data-border-right");
				if (after && !rightBorder) {
					rightBorder = after.getAttribute("data-border-left");
				}
				rightBorder = o[rightBorder || ""] || "";
				return leftBorder + align + rightBorder;
			}
			this.generate = function() {
				var start = +new Date()
				this.buildBlacklist();
				var format = $id("format")
					.value;
				this.log = "";
				if (format == "latex") {
					$id("c")
						.value = this.generateLaTeX();
				} else {
					this.interpret(format);
				}
				sendGAEvent("Code", "generate", format)
				this.message("Generated in " + ((+new Date()) - start) + "ms");
				$id("log")
					.innerHTML = "<strong>Log</strong> (" + ((new Date())
						.toLocaleTimeString()) + ")<hr>" + this.log;
			}
			this.headers = function(matrix){
				matrix = matrix || this.matrix();
				var headers = [], colHeaders = [], widthArray = [], _this = this, table = this.element;
				if(this.shrink){
					this.element.style.width = "390pt";
					for(var i=0;i<table.rows.length;i++){
						var cells = table.rows[i].cells;
						for(var j=0;j<cells.length;j++){
							cells[j].style.wordBreak = "break-all";
						}
					}
					var fakeRow = document.createElement("tr");
					for(var i=0;i<matrix[0].length;i++){
						fakeRow.appendChild(document.createElement("td"));
					}
					table.appendChild(fakeRow);
					for(var i=0;i<fakeRow.childNodes.length;i++){
						widthArray.push(Math.round(fakeRow.childNodes[i].scrollWidth/table.scrollWidth*1000)/1000);
					}
					for(var i=0;i<table.rows.length;i++){
						var cells = table.rows[i].cells;
							for(var j=0;j<cells.length;j++){
							cells[j].style.wordBreak = "";
						}
					}
					table.removeChild(fakeRow);
					this.element.style.width = "";
				}

				var colLength = 0;
				for(var i=0;i<matrix.length;i++){
					colLength = Math.max(colLength, matrix[i].length);
				}
				var actualColor = this.actualColor;					
				for(var j=0;j<colLength;j++){
					actualColor = this.actualColor;
					var headernow = {},
					    colorArr = {},
					    cellsArrays = {}
					for(var i=0;i<matrix.length;i++){
						var cell = matrix[i][j];
						if((cell.refCell||cell).cell.colSpan > 1){
							if(!cell.refCell){
								if(this.shrink){
									var total = 0;
									for(var k=0;k<cell.cell.colSpan;k++){
										total += widthArray[cell.x+k];
									}
									cell.shrinkRatio = Math.floor(total*1000)/1000;
								}
							}
							continue;
						}
						if(cell && !cell.ignore){
							if(this.shrink && widthArray[cell.x]){
								cell.shrinkRatio = widthArray[cell.x];
							}
							var align = (cell.refCell||cell).getHeader(actualColor, true);
							colorArr[align] = this.actualColor;
							this.actualColor = actualColor;
							if(!headernow[align]){
								headernow[align] = 0;
							}
							if(!cellsArrays[align]){
								cellsArrays[align] = [];
							}
							headernow[align]++;
							cellsArrays[align].push(cell);
						}
					}
					var max = 0, value = "l";
					for (var k in headernow) {
						if (headernow.hasOwnProperty(k) && headernow[k] > max) {
							max = headernow[k];
							value = k;
						}
					}
					var cellsArray = cellsArrays[value];
					for(var k=0;k<cellsArray.length;k++){
						cellsArray[k].isInPreambule = true;
					}
					colHeaders.push(value);
					this.actualColor = colorArr[value]
				}
				return colHeaders;
			}
			this.useTabu = false;
			this.togglePin = (function(){
				var isPinned = false;
				return function(){
					var nav = document.getElementsByTagName("nav")[0],
					height = nav.offsetHeight;
					if(isPinned){
						$(".hide-on-full").show();
						document.body.style.paddingTop = "";
						nav.style.position = "static";
					}
					else{
						$(".hide-on-full").hide();
						document.body.style.paddingTop = (height+20) + "px";
						nav.style.position = "fixed";
						nav.style.left = 0;
						nav.style.right = "300px";
						nav.style.top = 0;						
					}
					isPinned = !isPinned;
				}
			})();
			this.shouldUseTabu = function(){
				if(this.blacklistPackages["tabu"]){
					return false;
				}
				else if(this._id("opt-latex-tabu").checked){
					return true;
				}
				else if(this.blacklistPackages["arydshln"]){
					return this.hasBorderType("hdashline") || this.hasBorderType("dottedline");
				}
				else{
					// TODO : Detect hhline
					return false;
				}
			}
			this.hasBorderType = function(type){
				return !!this.element.querySelector("td[data-border-left='"+type+"'],td[data-border-bottom='"+type+"'],td[data-border-top='"+type+"'],td[data-border-right='"+type+"']")
			}
			this.shrink = false;
			this.useBooktab = function(){
				return this.element.hasAttribute("data-booktabs") ||
				this.hasBorderType("toprule") || this.hasBorderType("midrule") ||
				this.hasBorderType("bottomrule");
			}
			this.useBackgroundColor = function(matrix){
				if(matrix){
					for(var i=0;i<matrix.length;i++){
						var row = matrix[i];
						for(var j=0;j<row.length;j++){
							if(row[j].background){
								return true;
							}
						}
					}
				}
				return false;
			}
			this.tabuColor = function(color){
				if(typeof color == "string"){
					color = toRGBA(color);
				}
				var hex = "#" + ((1 << 24) + (color[0] << 16) + (color[1] << 8) + color[2]).toString(16).slice(1);
				color = [color[0],color[1],color[2]].map(function(n){
					return Math.floor((n/255)*1000)/1000
				});
				var sep = color.join(",");
				if(defaultColors[sep]){
					return defaultColors[sep];
				}
				else if(this.tabuColors[sep]){
					return this.tabuColors[sep].name
				}
				else{
					var prename = ntc.name(hex), name;
					if(!prename){return "black"}
					prename = prename[1];
					if(!prename){return "black"}
					prename = prename.replace(/[^a-zA-Z]/g, "");
					for(var i=0;true;i++){ // infinite loop
						name = prename
						if(i>0){
							name += toZZZ(i);
						}
						if(!this.tabuColorsDic[name]){
							break;
						}
					}
					this.tabuColorsDic[name] = sep;
					this.tabuColors[sep] = {
						name : name,
						rgb: color,
						hex : hex
					}
					this.packages["color"] = true;
					return name;
				}
			}
			this.tabuColors = {
			}
			this.tabuColorsDic = {};
			this.generateLaTeX = function(opt) {
				this.tabuColors = {};
				this.tabuColorsDic = {};
				this.packages = {};
				this.actualMainColor = this.mainColor();
				this.actualColor = this.actualMainColor;
				this.useTabu = this.shouldUseTabu(); // Must we use "tabu" package ?
				;;;; this.useTabu = true;
				;;;; this.blacklistPackages["arydshln"] = true;
				if(this.useTabu){
					// we avoid \arrayrulecolor
					this.actualMainColor = this.actualColor = "#000000";
				}
				if(!this.useTabu && (this.hasBorderType("hdashline") || this.hasBorderType("dottedline"))){
					this.packages["arydshln"] = true;
				}
				var table = this.element,
					fit = $id("opt-fit-table").value,
					scale = fit.indexOf("sc") >= 0,
					shrink = fit.indexOf("sh") >= 0,
					firstPart = "",
					float = this._id("opt-latex-float").checked,
					str = "";
				this.shrink = shrink;
				var caption = this.caption(),
					booktabs = table.hasAttribute("data-booktabs"),
					rg = this.matrix(),
					border,
					useTabu = this.useTabu, // Must we use "tabu" package ?
					asteriskMultirow = false;
				noColor = this.blacklistPackages["colortbl"];
				var colHeaders = this.headers(rg),
				borderNewLine = $id("opt-latex-border").checked,
				header = colHeaders.join(""),
				startingDshCommand = "",
				startingColor = this.actualMainColor;
				if(header.charAt(0) == "@"){
					header = header.replace(/^@\{(\\array[^\{]+\{[^\}]+\})\}/, function(full, command){
						startingDshCommand = command;
						command.replace(/\{[\s,]*([\d.]+)[\s,]*([\d.]+)[\s,]*([\d.]+)[\s,]*\}/, function(full, r, g, b){
							startingColor = "rgb("+(+r*255)+","+(+g*255)+","+(+b*255)+")";
						})
						return "";
					})
				}
				this.actualColor = startingColor;
				if(float){
					firstPart = "\\begin{table}\n";
				}
				else{
					firstPart = "\\begin{minipage}{\\columnwidth}\n";
				}
				if(this._id("table-opt-center").checked){
					firstPart += "\\centering\n"
				}
				if(this.useBooktab() && this.useBackgroundColor(rg)){
					firstPart += "\\setlength{\\extrarowheight}{0pt}\n";
					firstPart += "\\addtolength{\\extrarowheight}{\\aboverulesep}\n";
					firstPart += "\\addtolength{\\extrarowheight}{\\belowrulesep}\n";
					firstPart += "\\setlength{\\aboverulesep}{0pt}\n";
					firstPart += "\\setlength{\\belowrulesep}{0pt}\n";
				}
				if (caption.caption) {
					if(caption.numbered){
						this.packages["caption"] = true;
						firstPart += "\\captionsetup{labelformat=empty}\n";
					}
					if(float){
						firstPart += "\\caption{" + caption.caption + "}\n";
					}
					else{
						firstPart += "\\captionof{table}{" + caption.caption + "}";
					}
				}
				if (caption.label) {
					if(!caption.caption){
						firstPart += "\\refstepcounter{table}\n";
					}
					firstPart += "\\label{" + caption.label + "}\n";
				}
				if(!areSameColors(startingColor, "black")){
					firstPart += "\\arrayrulecolor" + getColor(startingColor) + "\n";
				}
				if(scale){
					this.packages["graphicx"] = true;
					str += "\\resizebox{\\columnwidth}{!}{%\n";
				}
				if(useTabu){
					this.packages["tabu"] = true;
				}
				str += "\\begin{"+(useTabu ? "tabu" : "tabular")+"}{" + header + "}";
				var rg2 = [],
				multiRows = {};
				for(var i=0;i<rg.length;i++){
					var cells = rg[i];
					var row = []
					for(var j=0;j<cells.length;j++){
						var cell = cells[j],
						header = colHeaders[j] || "l";
						if(cell.rowSpan > 1){
							for(var k=i;k<i+cell.rowSpan;k++){
								multiRows[k] = true;
							}
						}
						if(!cell || cell.ignore){
							row.push(false);
						}
						else{
							if(cell.switch){
								cell = rg[i+cell.rowSpan-1][j]
								cell.unswitch = true;
							}
							else if(cell.unswitch){
								cell = cell.refCell
							}
							row.push({
									text: cell.getFullContent(this.actualColor), 
									colSpan : cell.colSpan || (cell.refCell ? cell.refCell.colSpan : 1) || 1
								 })
						}
					}
					rg2.push(row);
				}
				var beautifyRows = this.beautifyRows(rg2);
				for(var i=0;i<beautifyRows.length;i++){
					var row = beautifyRows[i];
					if (i === 0 && booktabs) {
						if(borderNewLine){
							border = " \n\\toprule";
						}
						else{
							border = " \\toprule";
						}
					} else {
						border = this.getBorder(i, rg);
						if(borderNewLine){
							border = border ? " \n" + border : ""
						}
						else{
							border = border ? " " + border : "";
						}
					}
					if (i !== 0) {
						str += " \\\\";
						if(asteriskMultirow && multiRows[i]){
							str+= "*";
						}
						str += border
					} else {
						str += border;
					}
					str += "\n" + row;
				}
				if (booktabs) {
					str += " \\\\"+ (borderNewLine ? "\n" : " ") +"\\bottomrule"
				} else {
					border = this.getBorder(rg.length, rg);
					if (border) {
						str += " \\\\"+ (borderNewLine ? "\n" : " ") + border;
					}
				}
				str += "\n\\end{"+(useTabu ? "tabu" : "tabular")+"}\n"
				if(scale){
					str += "}\n";
				}
				// Booktabs
				if (/\\(bottomrule)|(toprule)|(midrule)|(cmidrule)|(heavyrulewidth)|(lightrulewidth)/.test(str)) {
					this.packages["booktabs"] = true;
				}
				// arydshln
				if (/\\(cdashline|hdashline)/.test(str)) {
					this.packages["arydshln"] = true;
				}
				if(str.indexOf("\\hhline")>-1){
					this.packages["hhline"] = true;
				}
				if(str.indexOf("\\arrayrulecolor") > -1 || firstPart.indexOf("\\arrayrulecolor") > -1 
				   || str.indexOf("\\doublerulesepcolor") > -1 || firstPart.indexOf("\\doublerulesepcolor") > -1){
					this.packages["colortbl"] = true;
					if(!areSameColors(this.actualColor, "#000000")){
						str += "\\arrayrulecolor"+getColor("#000000")+"\n";
					}
					if(!this.useTabu && this.packages["arydshln"]){
						firstPart += "\\ADLnullwidehline\n";
					}
				}
				if(this.useTabu){
					// Let see if we have some colors from tabu that we have to declare
					var tabuColors = this.tabuColors;
					for(var i in tabuColors){
						if(tabuColors.hasOwnProperty(i)){
							var color = tabuColors[i];
							firstPart += "\\definecolor{"+color.name+"}{rgb}{"+color.rgb.join(",")+"}\n";
						}
					}
				}
				if(float){
					str +="\\end{table}";
				}
				else{
					str += "\\end{minipage}";
				}
				// Packages
				var packages = "";
				for (var i in this.packages) {
					if (this.packages.hasOwnProperty(i)) {
						if(i == "ulem"){
							packages += "% \\usepackage[normalem]{ulem}\n";
						}
						else if(i != "arydshln" && !(i == "color" && this.packages["colortbl"])){
							packages += "% \\usepackage{" + i + "}\n";
						}
					}
				}
				if (!useTabu && this.packages["arydshln"]) {
					// Compatibility between packages
					packages += "% \\usepackage{arydshln}\n";
				}
				/* Show some message*/
				if (this.shrink && this.packages["multirow"]){
					this.message("The shrink algorithmn might not work with cells spanning multiple rows.","warning");
				}
				if (this.element.querySelector("td[data-two-diagonals]")) {
					this.message(
						"If you get an '! FP error: Logarithm of negative value!.' error, the content of the bottom part of one of your cells with two diagonals is too long.", "warning"
					)
				}
				/* Show some information about packages used */
				this.showPackagesInformation(this.packages);
				return (packages ? packages + "\n\n" : "") + firstPart + str;
			}
			this.showPackagesInformation = function(packages){

				var packs = [],
				packDatabase = {},
				hasSub = false;
				var _packinfo = function(pack, sub){
					if(packDatabase[pack]){
						return;
					}
					packDatabase[pack] = true;
					if(sub){hasSub = true;}
					packs.push("<span class='package'>"+pack+"</span>" + (sub ? "<sup>*</sup>" : ""));
					if(packagesDatabase[pack]){
						for(var j=0;j<packagesDatabase[pack].length;j++){
							_packinfo(packagesDatabase[pack][j], true);
						}
					}
				}
				for (var i in this.packages) {
					if (this.packages.hasOwnProperty(i)) {
						_packinfo(i, false);
					}
				}
				if(packs.length == 0){return false}
				if(packs.length == 1){
					this.message("This table will import one package : " + packs[0] + ".", "info");
				}
				else if(packs.length > 1){
					packs.sort();
					var last = packs[packs.length-1];
					packs.pop()
					this.message("This table will import "+ (packs.length+1) +" packages : "+ packs.join(", ") + ", and "+ last+"." +
					(hasSub ? "<br><small>* This package is imported by another package.</small>" : ""), "info");
				}
			}
			this.beautifyRows = function(rows){
				var rows2 = [], n = 0, start = [], max = [];
				if($id("opt-latex-whitespace").checked){
					for(var i=0;i<rows.length;i++){
						rows2[i] = "";
						var cells = rows[i];
						for(var j=0;j<cells.length;j++){
							var cell = cells[j];
							if(cell){
								if(j!==0){
									rows2[i] += " & ";
								}
								rows2[i] += cell.text;
							}
						}
					}
					return rows2;
				}
				for(var i=0;i<rows.length;i++){
					rows2.push("");
					start.push(0);
					max.push(0);
					n = Math.max(n, rows[i].length);
				}
				for(var i=0;i<n;i++){
					var unspace = false;
					for(var j=0;j<rows.length;j++){
						var cell = rows[j][i];
						if(start[j] != i){continue}
						if(i !== 0){
							var submax = max[i-1];
							for(var k=rows2[j].length;k<submax+1;k++){
								rows2[j]+= " ";
							}
							rows2[j] += "& ";
						}
						rows2[j]+= cell.text;
						max[i] = Math.max(max[i], rows2[j].length);
						start[j]+= cell.colSpan;
					}
				}
				max = 0;
				for(var i=0;i<rows2.length;i++){
					max = Math.max(max, rows2[i].length);
				}
				for(var i=0;i<rows2.length;i++){
					for(var j=rows2[i].length;j<max+1;j++){
						rows2[i]+= " ";
					}
				}
				return rows2;
			}
			this.extract = (function() {
				function borderInfo(cell, o) {
					var style = cell.style,
						css = "",
						types = {
							"solid": ["normal", "1px solid "],
							"double": ["double", "2px solid "],
							"dashed": ["hdashline", "1px dashed "],
							"dotted": ["dottedline", "1px dotted "]
						},
						first = "";
					["Left", "Right", "Bottom", "Top"].forEach(function(val) {
						var type = style["border" + val + "Style"];
						if (type && type != "none") {
							var valLC = val.toLowerCase(),
								res = types[type] || ["normal", "1px solid "];
								res[1] += style["border" + val + "Color"] || "black";
							o.dataset["border" + val] = res[0];
							css += "border-" + valLC + ":" + res[1] + ";";
							if (!first) {
								first = res[1];
							}
						}
					});
					if (first && first == style.border) {
						return "border: " + first + ";";
					}

					return css;
				}
				function backgroundInfo(cell){
					var color = window.getComputedStyle(cell,null).getPropertyValue("background-color");
					if(color == "transparent" || color == "white"){return ""}
					var rgba = toRGBA(color);
					alert(rgba);
					if(rgba[3] == 0){
						return "";
					}
					rgba.pop();
					if(rgba.join(",") == "255,255,255"){
						return "";
					}
					return "background-color: "+color+";";
				}
				function getHTML(html) {
					html = html.replace(/<\s*\/?\s*([^>]+)>/gi, function(a, b) {
						if (!/^((em)|i)($|[^a-z])/i.test(b)) {
							return "";
						}
						return a;
					});
					var div = document.createElement("div");
					div.innerHTML = html;
					return div.innerHTML;
				}
				return function(div) {
					var table = div.querySelector("table");
					if (!table) {
						return;
					}
					var o = {
						autoBooktabs: false,
						cells: []
					}
					// Caption
					var wordCaption = div.querySelector(".MsoCaption") || table.caption;
					o.caption = {
						caption: wordCaption ? (wordCaption.innerText || wordCaption.textContent) : table.title || "",
						numbered: false,
						label: table.id || ""
					}
					for (var i = 0; i < table.rows.length; i++) {
						var cells = table.rows[i].cells;
						o.cells[i] = [];

						for (var j = 0; j < cells.length; j++) {
							var cell = cells[j],
								o2 = {
									dataset: {}
								};
							if ((cell.getAttribute("style") || cell.style.cssText)
								.indexOf("mso-diagonal") > -1) {
								o2.dataset.diagonal = "data-diagonal";
								o2.html = [getHTML(cell.innerHTML), ""]
							} else {
								o2.html = getHTML(cell.innerHTML);
							}
							o2.css = borderInfo(cell, o2) + backgroundInfo(cell);
							o2.rowSpan = cell.rowSpan;
							o2.colSpan = cell.colSpan;
							o.cells[i][j] = o2;
						}
					}
					this.importFromJSON(o);
				}
			})()
			this.HBorder = function(n, callback, matrix) {
				var row = matrix[Math.max(0, (n || 0) - 1)],
				types = {};
				if (!row) {
					return callback.call(this)
				}
				var border = [],
					hasColor = false,
					subBorder = {},
					complete = true,
					actualColor = this.actualColor;
				if (n == 0) {
					for (var i = 0; i < row.length; i++) {
						if (row[i].refCell) {
							continue;
						}
						var cell = row[i].cell,
							bd = cell.getAttribute("data-border-top"),
							color = cell.style.borderTopColor;
						if (bd) {
							var o = {
								type : bd,
								color : color,
								sameAsBefore : i===0,
								cellIndex : i
							}
							types[bd] = true;
							if(border[i-1]){
								var beforeBorder = border[i-1];
								if(areSameColors(beforeBorder.color, o.color) && o.type == beforeBorder.type){
									o.sameAsBefore = true;
								}
							}
							if(!o.sameAsBefore){
								complete = false;
							}
							if(!hasColor && !areSameColors("#000000", o.color)){
								hasColor = true;
							}
							for (var j = 0; j < cell.colSpan; j++) {
								border.push(o);
								i++;
							}
							i--;
						}
						else {
							if(border[i-1]){
								complete = false;
							}
							for (var j = 0; j < cell.colSpan; j++) {
								border.push(false);
								i++;
							}
							i--;
						}
					}
				} else {
					var row2 = matrix[n] || [];
					for (var i = 0; i < row.length; i++) {
						var cell = row[i];
						cell = cell.cell || cell.refCell.cell;
						if (cell.parentElement.rowIndex + cell.rowSpan != n) {
							if(border[i-1]){
								complete = false;
							}
							for (var j = 0; j < cell.colSpan; j++) {
								border.push(false);
								i++;
							}
							i--;
							continue;
						}
						var bd = cell.getAttribute("data-border-bottom"),
						color = cell.style.borderBottomColor;
						if (!bd && row2[i]) {
							var cell = row2[i];
							if (cell.cell || (cell.refCell.cell.parentElement.rowIndex == n + 1)) {
								bd = (cell.cell || cell.refCell.cell)
									.getAttribute("data-border-top"),
								color = (cell.cell || cell.refCell.cell).style.borderTopColor;
							}
						}
						if (bd) {
							var o = {
								type : bd,
								color : color,
								sameAsBefore : i===0,
								cellIndex : i
							}
							types[bd] = true;
							if(border[i-1]){
								var beforeBorder = border[i-1];
								if(areSameColors(beforeBorder.color, o.color) && o.type == beforeBorder.type){
									o.sameAsBefore = true;
								}
							}
							if(!o.sameAsBefore){
								complete = false;
							}
							if(!hasColor && !areSameColors("#000000", o.color)){
								hasColor = true;
							}
							for (var j = 0; j < cell.colSpan; j++) {
								border.push(o);
								i++;
							}
							i--;
						} else {
							if(border[i-1]){
								complete = false;
							}
							for (var j = 0; j < cell.colSpan; j++) {
								border.push(false);
								i++;
							}
							i--;
						}
					}
				}
				return callback.call(this, {
					complete: complete,
					color : hasColor,
					borders : border,
					types : types
				});
			}
			this.actualMainColor = "black";
			this.actualColor = "black";
			this.mainColor = function(){
				var rows = this.element.rows,
				colors = {};
				for(var i=0;i<rows.length;i++){
					var cells = rows[i].cells;
					for(var j=0;j<cells.length;j++){
						var cell = cells[j];
						["Top","Bottom","Right","Left"].forEach(function(Side){
							var side = Side.toLowerCase();
							if(cell.getAttribute("data-border-"+side)){
								var color = cell.style["border"+Side+"Color"];
								if(!colors[color]){colors[color]=0};
								colors[color]++;
							}
						});
					}
				}
				var max = 0, actual = "black";
				for(var i in colors){
					if(colors.hasOwnProperty(i)){
						if(colors[i]>max){
							max = colors[i];
							actual = i;
						}
					}
				}
				return actual;
			}
			this.prepareDownload = function() {
				var latex = this.generateLaTeX();
				latex = latex.replace(/^%\s*\\usepack/mg, "\\usepack");
				latex = "\\documentclass{article}\n" + latex;
				latex = latex.replace(/\\begin{tabl/, "\\begin{document}\n\\begin{tabl") + "\n\\end{document}";
				var blob = new Blob([latex],{type : 'application/x-tex'}); 
				var fileReader = new FileReader();
				fileReader.onload = function(e) {
				     $id("link-download").href = e.target.result;
				     $('#download').modal('show');
				};
				fileReader.readAsDataURL(blob);
				$id("link-download")
					.href = "";
			}
			this.getBorder = function(n, matrix) {
				return this.HBorder(n, function(o) {
					if (arguments.length == 0) {
						return ""
					}
					var complete = o.complete,
					hasColor = o.color,
					borders = o.borders,
					border = "",
					enhanceHhline = this._id("opt-latex-hhline").checked && (!this.packages["arydshln"] || this.useTabu),
					insertInHhline = !this.blacklistPackages["colortbl"];
					if(complete){
						if(!borders[0]){
							return "";
						}
						var firstBorder = borders[0];
						if(hasColor && !(this.useTabu && (firstBorder.type == "hdashline" || firstBorder.type == "dottedline"))){
							border += "\\arrayrulecolor"+getColor(firstBorder.color);
							this.actualColor = firstBorder.color;
						}
						if(firstBorder.type == "double" && enhanceHhline){
							// We use hhline for this double
							var insideColor = this.actualColor;
							this.packages["hhline"] = true;
							border += "\\hhline{";
							var row = matrix[n] || matrix[n-1];
							for(var i=0;i<borders.length;i++){
								var borderLeft = (row[i].refCell||row[i]).leftBorder,
								  	borderLeftColor = (row[i].refCell||row[i]).leftBorderColor;
								if((borderLeft == "normal" && i==0) || borderLeft == "double"){
									if(insertInHhline && !areSameColors(insideColor, borderLeftColor)){
										insideColor = borderLeftColor;
										border += ">{\\arrayrulecolor"+getColor(borderLeftColor)+"}";
									}
									if(borderLeft == "normal"){
										border += "|";
									}
									else{
										if(i == 0){
											border += "|";
										}
										else{
											border += ":";
										}
										if(n == 0){
											border += "t";
										}
										else if(n >= matrix.length){
											border += "b";
										}
										border += ":";
									}
								}
								border += "=";
								var borderRight = (row[i].refCell||row[i]).rightBorder,
								    borderRightColor = (row[i].refCell||row[i]).rightBorderColor;
								if(borderRight == "normal" || borderRight == "double"){
									if(insertInHhline && !areSameColors(insideColor, borderRightColor)){
										insideColor = borderRightColor;
										border += ">{\\arrayrulecolor"+getColor(borderRightColor)+"}";
									}
									if(borderRight == "normal"){
										border += "|";
									}
									else{
										border += ":";
										if(n == 0){																				border += "t"
										}
										else if(n >= matrix.length){
											border += "b";
										}
										if(i >= row.length-1){
											border += "|";
										}
										else{
											border += ":";
										}
									}
								}
							}
							border += "}";
						}
						else if(this.useTabu && hasColor && (firstBorder.type == "hdashline" || firstBorder.type == "dottedline")){
							var colorname = this.tabuColor(firstBorder.color);
							if(firstBorder.type == "hdashline"){
								border += "\\tabucline["+colorname+" on 4pt off 4pt]{-}"
							}
							else{
								border += "\\tabucline["+colorname+" on 1pt off 1pt]{-}"
							}
						}
						else{
							border += {
									normal: "\\hline",
									double: "\\hline\\hline",
									toprule: "\\toprule",
									midrule: "\\midrule",
									bottomrule: "\\bottomrule",
									hdashline: this.useTabu ? "\\tabucline[on 4pt off 4pt]{-}" : "\\hdashline",
									dottedline: this.useTabu ? "\\tabucline[on 1pt off 1pt]{-}" : "\\hdashline[1pt/1pt]"
							}[firstBorder.type]
						}
						return border;
					}
					var row = matrix[n] || matrix[n-1],
					useHHLine = false;
					for(var i=0;i<row.length;i++){
						var cell = row[i];
						if((cell.refCell||cell).background){
							useHHLine = true;
							break;
						}
					}
					if((useHHLine								// If there's a cell with background color
						|| hasColor							// or colored rules
						|| (o.types.double && 						// or a double border but
						   !(o.types.toprule || o.types.midrule || o.types.bottomrule))	// without booktab borders
						) && (!this.packages["arydshln"] || this.useTabu)		// And we don't use arydshln package
					){
						// oh oh... We must use a hhline
						var insideColor = this.actualColor,
						doublerulesepcolor = [255,255,255,1], // white
						metAry = false,
						width = "0.4pt",
						widthKeys = {
							"toprule" : "\\heavyrulewidth",
							"bottomrule" : "\\heavyrulewidth",
							"midrule" : "\\cmidrulewidth",
							"normal" : "0.4pt",
							"double" : "0.4pt"
						}
						border = "\\hhline{";
						for(var i=0;i<borders.length;i++){
							if(i===0){
							// Must check for left border
								var borderLeft = (row[i].refCell||row[i]).leftBorder,
								    borderLeftColor = (row[i].refCell||row[i]).leftBorderColor;
								if(borderLeft == "normal" || borderLeft == "double"){
									if(insertInHhline && !areSameColors(insideColor, borderLeftColor)){
										insideColor = borderLeftColor;
										border += ">{\\arrayrulecolor"+getColor(borderLeftColor)+"}";
									}
									if(borderLeft == "normal"){
										border += "|";
									}
									else{
										if(enhanceHhline){
											border += "|";
											if(n == 0){
												border += "t";
											}
											else if(n >= matrix.length){
												border += "b";
											}
											if(borders[i].type == "double"){
												border += ":";
											}
											else{
												border += "|";
											}
										}
										else{
											border += "||";
										}
									}
								}
							}
							// Now the horizontal border
							var type = borders[i].type,
							color = borders[i].color,
							background = (row[i].refCell||row[i]).background,
							thiswidth = widthKeys[type] || "0.4pt";
							if(type == "normal" || type == "toprule" || type == "bottomrule" || type == "midrule"){
								if(insertInHhline){
									var toadd = "";
									if(!areSameColors(insideColor, color)){
										insideColor = color;
										toadd += "\\arrayrulecolor"+getColor(color);
									}
									if(width != thiswidth){
										width = thiswidth;
										toadd += "\\setlength{\\arrayrulewidth}{"+thiswidth+"}";
										this.packages["colortbl"] = true;
									}
									if(toadd){
										border+= ">{"+toadd+"}";
									}
								}
								border += "-";
							}
							else if(type == "double"){
								if(insertInHhline){
									var toadd="";
									background = background || [255,255,255,1];
									if(!areSameColors(insideColor, color)){
										insideColor = color;
										toadd += "\\arrayrulecolor"+getColor(color);
									}
									if(!areSameColors(doublerulesepcolor, [255,255,255,1])){
										doublerulesepcolor = "FFFFFF";
										toadd += "\\doublerulesepcolor"+getColor([255,255,255,1]);
									}
									if(width != thiswidth){
										width = thiswidth;
										toadd += "\\setlength{\\arrayrulewidth}{"+thiswidth+"}";
									}
									if(toadd){
										border += ">{" + toadd + "}";
									}
								}
								border += "=";
							}
							else if(type == "dottedline" || type == "hdashline"){
								metAry = true;
								border += "~";
							}
							else if(background){
								if(insertInHhline){
									var toadd="";
									if(!areSameColors(insideColor, background)){
										insideColor = background;
										toadd += "\\arrayrulecolor"+getColor(background);
									}
									if(o.types.double){
										if(!areSameColors(doublerulesepcolor, background)){
											doublerulesepcolor = background;
											toadd += "\\doublerulesepcolor"+getColor(background);
										}
									}
									else if(o.types.toprule || o.types.bottomrule || o.types.midrule){
										if(o.types.toprule || o.types.bottomrule){
											thiswidth = widthKeys["toprule"];
										}
										else{
											thiswidth = widthKeys["midrule"];
										}
										if(width != thiswidth){
											width = thiswidth;
											toadd += "\\setlength{\\arrayrulewidth}{"+thiswidth+"}";
										}
									}
									if(toadd){
										border += ">{" + toadd + "}";
									}
								}
								if(o.types.double){
									border += "=";
								}
								else{
									border += "-";
								}
							}
							else{
								border += "~";
							}
							// Check for right border;
							var borderRight = (row[i].refCell||row[i]).rightBorder,
							    borderRightColor = (row[i].refCell||row[i]).rightBorderColor;
							if(borderRight == "normal" || borderLeft == "double"){
								if(insertInHhline && !areSameColors(insideColor, borderRightColor)){
									insideColor = borderRightColor;
									border += ">{\\arrayrulecolor"+getColor(borderRightColor)+"}";
								}
								if(borderRight == "normal"){
									border += "|";
								}
								else{
									if(enhanceHhline){
										if(type == "double"){
											border += ":";
										}
										else{
											border += "|";
										}
										if(n == 0){
											border += "t";
										}
										else if(n >= matrix.length){
											border += "b";
										}
										if(i >= row.length-1){
											border += "|";
										}
										else{
											if(borders[i+1].type == "double"){
												border += ":"
											}
											else{
												border += "|";
											}
										}
									}
									else{
										border += "||";
									}
								}
							}
						}
						border += "}";
						// Remove useless hhline. Faster this way.
						border = border.replace(/\\hhline{[^=-]*}$/, "");
						if(metAry){
							for(var i=0;i<borders.length;i++){
								if(borders[i]){
									var type = borders[i].type,
									color = borders[i].color;
									if(type == "hdashline" || type == "dottedline"){
										var colorname = this.tabuColor(color);
										if(type == "hdashline"){
											border+="\\tabucline["+colorname+" on 4pt off 4pt]{"+(i+1);
										}
										else{
											border+="\\tabucline["+colorname+" on 1pt off 1pt]{"+(i+1);
										}
										while(true){	// We know what we are doing
											i++;
											var borderN = borders[i];
											if(!borderN || !borderN.sameAsBefore){
												border += "-" + i + "}";
												i--;
												break;
											}
										}
									}
								}
							}
						}
						return border;
					}
					else{
						var doubleBorder = false;
						for(var i=0;i<borders.length;i++){
							var borderO = borders[i];
							if(!borderO){
								continue;
							}
							var insideTabu = "";
							if(!areSameColors(this.actualColor, borderO.color)){
								if(this.useTabu){
									insideTabu = this.tabuColor(borderO.color)+" ";
								}
								else{
									this.actualColor = borderO.color;
									border+= "\\arrayrulecolor"+getColor(borderO.color);
								}
							}
							border += {
								normal: "\\cline",
								toprule: "\\cmidrule[\\heavyrulewidth]",
								midrule: "\\cmidrule",
								bottomrule: "\\cmidrule[\\heavyrulewidth]",
								hdashline: this.useTabu ? "\\tabucline["+insideTabu+"on 4pt off 4pt]" : "\\cdashline",
								dottedline: this.useTabu ? "\\tabucline["+insideTabu+"on 1pt off 1pt]" : "\\cdashline",
								double: "\\cmidrule"
							}[borderO.type] + "{" + (i+1);
							if(borderO.type == "double"){doubleBorder = true;}
							while(true){	// We know what we are doing
								i++;
								var borderN = borders[i];
								if(!borderN || !borderN.sameAsBefore){
									border += "-" + i + "}";
									i--;
									if(borderO.type == "dottedline" && !this.useTabu){
										border += "[1pt/1pt]";
									}
									break;
								}
							}
						}
						if(doubleBorder){
							border += "\\morecmidrule";
						}
						for(var i=0;i<borders.length;i++){
							// We repeat the same process as before but only for double borders. Why not just copy the
							// "double border" part ? In case the double border has color and the actual color changed
							// after.
							var borderO = borders[i];
							if(!borderO || borderO.type != "double"){
								continue;
							}
							if(!areSameColors(this.actualColor, borderO.color)){
								this.actualColor = borderO.color;
								border+= "\\arrayrulecolor"+getColor(borderO.color);
							}
							border += "\\cmidrule{"+ (i+1);
							while(true){	// We know what we are doing
								i++;
								var borderN = borders[i];
								if(!borderN || !borderN.sameAsBefore){
									border += "-" + i + "}";
									i--;
									break;
								}
							}
						}
						return border;
				
					}
					return "";
				}, matrix);
			}
		})()
	window.table = table;
})();
window.addEventListener("beforeunload", function() {
	if (window.table) {
		localStorage.setItem("table", JSON.stringify(table.exportToJSON()));
		if ($id("format")) {
			localStorage.setItem("table_format", $id("format")
				.value);
		}
	}
}, false);
(function(){
	var initialX = 0,
	initialY = 0,element, start = false;
	function intersectRect(r1, r2) {
	  return !(r2.left > r1.right || 
	           r2.right < r1.left || 
	           r2.top > r1.bottom ||
	           r2.bottom < r1.top);
	   }
	function calculate(x, y){
		if(document.body.hasAttribute("data-border-editor")){
			element.style.top = initialY + "px";
			element.style.left = initialX + "px";
			element.style.width = Math.sqrt((initialY-y)*(initialY-y)+(initialX-x)*(initialX-x))+"px";
			var angle = Math.atan2(x- initialX,- (y- initialY) )*(180/Math.PI)-90;
			element.style.transform = "rotate(" + angle + "deg)";
		}
	}
	window.addEventListener("selectstart", function(e){
		if(start){
			e.preventDefault();
			return false;
		}
	});
	window.addEventListener("mousedown", function(e){
		if(!element){
			element = document.getElementById('line');
		}
		if(document.body.hasAttribute("data-border-editor") && element){
			var overElement = e.target;
			if(!overElement || (overElement.tagName != "TEXTAREA" && overElement.tagName != "INPUT"
					    && overElement.tagName != "BUTTON" && overElement.tagName != "SELECT")){
				element.style.display="block";
				initialX = e.pageX;
				initialY = e.pageY;
				calculate(initialX, initialY);
				start = true;
			}
		}
	});
	window.addEventListener("mousemove", function(e){
		if(start){
			if(document.body.hasAttribute("data-border-editor") && element){
				calculate(e.pageX, e.pageY);
			}
			else{
				start = false;should = null;
			}
		}
	});
	window.addEventListener("mouseup", function(e){
		if(document.body.hasAttribute("data-border-editor") && element){
			var rectangle = {
						top : Math.min(initialY, e.pageY),
						bottom : Math.max(initialY, e.pageY),
						left : Math.min(initialX, e.pageX),
						right : Math.max(initialX, e.pageX)
					},
			tableElement = table.element;
			element.style.display="none";
			var should = null;
			if(Math.sqrt((rectangle.bottom-rectangle.top)*(rectangle.bottom-rectangle.top)+(rectangle.bottom-rectangle.top)
			   + (rectangle.right-rectangle.left)*(rectangle.right-rectangle.left))<8){
				for(var i=0;i<tableElement.rows.length;i++){
					var cells = tableElement.rows[i].cells;
					for(var j=0;j<cells.length;j++){
						var cell = cells[j],
						posCell = table._absolutePosition(cell);
						if(intersectRect(posCell, rectangle)){
							table.editBorder(cell, e.pageX, e.pageY)
							// Force exit
							j = cells.length;
							i = tableElement.rows.length;
							break;
						}
					}
				}
			}
			else if(Math.abs(initialY-e.pageY)<=10){
				var matrix = table.Table.matrix(),row;
				for(var i=0;i<matrix.length;i++){
					row = matrix[i];
					for(var j=0,cell,posCell;j<row.length;j++){
						cell = row[j];
						cell = (cell.refCell||cell).cell;
						posCell = table._absolutePosition(cell);
						if(intersectRect(posCell, rectangle)){
							var where = (rectangle.top+(rectangle.bottom-rectangle.top)/2 > posCell.top+posCell.height/2) 
								    ? "bottom" : "top";
							if(should === null){
								should = !table.isBorderSet(cell, where);
							}
							table.setBorder(cell, where, should)
						}
					}
				}
			}
			else if(Math.abs(initialX-e.pageX) <= 10){
				var matrix = table.Table.matrix(),row;
				for(var i=0;i<matrix.length;i++){
					row = matrix[i];
					for(var j=0,cell,posCell;j<row.length;j++){
						cell = row[j];
						cell = (cell.refCell||cell).cell;
						posCell = table._absolutePosition(cell);
						if(intersectRect(posCell, rectangle)){
							var where = (rectangle.left+(rectangle.right-rectangle.left)/2 > posCell.left+posCell.width/2)
								    ? "right" : "left";
							if(should === null){
								should = !table.isBorderSet(cell, where);
							}
							table.setBorder(cell, where, should)
						}
					}
				}
			}
			start = false;
			should = null;
			initialY = initialX = 0;
		};
	});
})();